{"ast":null,"code":"/* Smart UI v10.0.0 (2021-Aug) \nCopyright (c) 2011-2021 jQWidgets. \nLicense: https://htmlelements.com/license/ */\n\n/******/\n(() => {\n  // webpackBootstrap\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\n    2612:\n    /***/\n    () => {\n      Smart(\"smart-button\", class extends Smart.ContentElement {\n        static get properties() {\n          return {\n            value: {\n              type: \"string\"\n            },\n            name: {\n              type: \"string\"\n            },\n            type: {\n              value: \"button\",\n              type: \"string\"\n            },\n            clickMode: {\n              allowedValues: [\"hover\", \"press\", \"release\", \"pressAndRelease\"],\n              type: \"string\",\n              value: \"release\"\n            }\n          };\n        }\n\n        static get styleUrls() {\n          return [\"smart.button.css\"];\n        }\n\n        template() {\n          return \"<button class=\\\"smart-button smart-unselectable\\\" inner-h-t-m-l='[[innerHTML]]' id='button' type='[[type]]' name='[[name]]' value='[[value]]' disabled='[[disabled]]' role=\\\"presentation\\\"></button>\";\n        }\n\n        refresh() {}\n\n        static get listeners() {\n          return {\n            \"button.down\": \"_downHandler\",\n            \"button.mouseenter\": \"_mouseEnterHandler\",\n            \"button.mouseleave\": \"_mouseLeaveHandler\",\n            \"button.touchend\": \"_touchEndHandler\",\n            \"button.click\": \"_clickHandler\",\n            \"button.up\": \"_upHandler\",\n            up: \"_upHandler\",\n            \"button.focus\": \"_focusHandler\",\n            \"button.blur\": \"_blurHandler\"\n          };\n        }\n\n        focus() {\n          const e = this;\n          e.$.button ? e.$.button.focus() : HTMLElement.prototype.focus.call(e);\n        }\n\n        blur() {\n          const e = this;\n          e.$.button ? e.$.button.blur() : HTMLElement.prototype.blur.call(e);\n        }\n\n        _upHandler(e) {\n          const t = this;\n\n          if (e.stopPropagation(), t.$.setAttributeValue(\"active\", !1), t.dataset.target) {\n            const n = document.querySelector(t.dataset.target);\n            let a = t.dataset.toggle;\n\n            if (n && \"Smart-WINDOW\" === n.nodeName && \"modal\" === a && (a = \"openModal\"), \"tab\" === a || \"pill\" === a || \"list\" === a) {\n              const e = this.closest(\".nav, .list-group\"),\n                    a = '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',\n                    r = !e || \"UL\" !== e.nodeName && \"OL\" !== e.nodeName ? e.children(\".active\") : e.querySelectorAll(\"li > .active\");\n\n              if (e) {\n                const n = e.querySelectorAll(a);\n\n                for (let e = 0; e < n.length; e++) n[e].classList.remove(\"primary\");\n\n                for (let e = 0; e < r.length; e++) r[e].classList.remove(\"active\");\n\n                let i = t.parentNode;\n\n                for (; i;) {\n                  if (\"LI\" === i.nodeName) {\n                    i.classList.add(\"active\");\n                    break;\n                  }\n\n                  i = i.parentNode;\n                }\n\n                t.classList.add(\"primary\");\n              }\n\n              return n.parentNode.querySelectorAll(\".active\").forEach(e => {\n                e.classList.remove(\"active\"), e.classList.add(\"smart-hidden\");\n              }), n.classList.add(\"active\"), void n.classList.remove(\"smart-hidden\");\n            }\n\n            a && n && n[a] && (setTimeout(() => {\n              n[a]();\n            }, 50), e.originalEvent.preventDefault());\n          }\n        }\n\n        _focusHandler() {\n          this.$.setAttributeValue(\"focus\", !0), this.$.fireEvent(\"focus\");\n        }\n\n        _blurHandler() {\n          this.$.setAttributeValue(\"focus\", !1), this.$.fireEvent(\"blur\");\n        }\n\n        _clickHandler(e) {\n          const t = this;\n          (\"release\" !== t.clickMode && \"pressAndRelease\" !== t.clickMode || t.readonly) && (e.preventDefault(), e.stopPropagation());\n        }\n\n        _downHandler(e) {\n          const t = this;\n\n          if (!(t.disabled || (t.hasRippleAnimation && Smart.Utilities.Animation.Ripple.animate(t, e.pageX, e.pageY), t.$.setAttributeValue(\"active\", !0), \"press\" !== t.clickMode && \"pressAndRelease\" !== t.clickMode || t.readonly))) {\n            if (t.hasAttribute(\"smart-blazor\")) return void t.$.dispatchEvent(new Event(\"click\"));\n            const n = \"buttons\" in e ? e.buttons : e.which;\n            t.$.fireEvent(\"click\", {\n              buttons: n,\n              clientX: e.clientX,\n              clientY: e.clientY,\n              pageX: e.pageX,\n              pageY: e.pageY,\n              screenX: e.screenX,\n              screenY: e.screenY\n            });\n          }\n        }\n\n        _mouseEnterHandler(e) {\n          const t = this;\n\n          if (!t.readonly && (t.$button.setAttributeValue(\"hover\", !0), t.$.setAttributeValue(\"hover\", !0), \"hover\" === t.clickMode)) {\n            const n = \"buttons\" in e ? e.buttons : e.which;\n            if (t.hasAttribute(\"smart-blazor\")) return void t.$.dispatchEvent(new Event(\"click\"));\n            t.$.fireEvent(\"click\", {\n              buttons: n,\n              clientX: e.clientX,\n              clientY: e.clientY,\n              pageX: e.pageX,\n              pageY: e.pageY,\n              screenX: e.screenX,\n              screenY: e.screenY\n            });\n          }\n        }\n\n        _touchEndHandler() {\n          const e = this;\n          setTimeout(function () {\n            e.$button.setAttributeValue(\"hover\", !1), e.$.setAttributeValue(\"hover\", !1);\n          }, 300);\n        }\n\n        _mouseLeaveHandler() {\n          this.$button.setAttributeValue(\"hover\", !1), this.$.setAttributeValue(\"hover\", !1);\n        }\n\n        propertyChangedHandler(e, t, n) {\n          super.propertyChangedHandler(e, t, n);\n          const a = this;\n          \"disabled\" === e ? (a._setFocusable(), a.$button && a.$button.setAttributeValue(\"hover\", !1), a.$.setAttributeValue(\"hover\", !1), a instanceof Smart.RepeatButton && a._stopRepeat()) : \"unfocusable\" === e && a._setFocusable();\n        }\n\n        _setFocusable() {\n          const e = this,\n                t = e.$.button ? e.$.button : e;\n          if (e.disabled || e.unfocusable) return t.removeAttribute(\"tabindex\"), void (t.tabIndex = -1);\n          t.tabIndex = e.tabIndex > 0 ? e.tabIndex : 0;\n        }\n\n        ready() {\n          const e = this;\n          super.ready(), e.setAttribute(\"role\", \"button\"), e._setFocusable(), e.enableShadowDOM && e.$.hiddenInput && e.appendChild(e.$.hiddenInput);\n        }\n\n      }), Smart(\"smart-repeat-button\", class extends Smart.Button {\n        static get properties() {\n          return {\n            delay: {\n              value: 50,\n              type: \"number\"\n            },\n            initialDelay: {\n              value: 150,\n              type: \"number\"\n            }\n          };\n        }\n\n        static get listeners() {\n          return {\n            \"button.down\": \"_startRepeat\",\n            \"button.mouseenter\": \"_overriddenHandler\",\n            \"button.mouseleave\": \"_overriddenHandler\",\n            \"button.pointerenter\": \"_updateInBoundsFlag\",\n            \"button.pointerleave\": \"_updateInBoundsFlag\",\n            \"button.touchmove\": \"_touchmoveHandler\",\n            \"document.up\": \"_stopRepeat\"\n          };\n        }\n\n        _clickHandler(e) {\n          const t = this;\n          (\"release\" !== t.clickMode || t.preventDefaultClick || t.readonly || t.disabled) && (e.preventDefault(), e.stopPropagation(), t.preventDefaultClick = !1);\n        }\n\n        _updateInBoundsFlag(e) {\n          const t = this;\n          -1 !== e.type.indexOf(\"leave\") ? (t._isPointerInBounds = !1, t.$button.setAttributeValue(\"hover\", !1), t.$.setAttributeValue(\"hover\", !1)) : (t._isPointerInBounds = !0, t.$button.setAttributeValue(\"hover\", !0), t.$.setAttributeValue(\"hover\", !0)), 1 !== (\"buttons\" in e ? e.buttons : e.which) && t._stopRepeat(e);\n        }\n\n        _startRepeat(e) {\n          const t = this;\n          t.setAttribute(\"active\", \"\"), t._initialTimer || t.readonly || (t._initialTimer = setTimeout(function () {\n            t._repeatTimer = setInterval(() => {\n              if (t._isPointerInBounds) {\n                if (t.hasAttribute(\"smart-blazor\")) return t.$.dispatchEvent(new Event(\"click\")), void (t.preventDefaultClick = !0);\n                const n = \"buttons\" in e ? e.buttons : e.which;\n                t.$.fireEvent(\"click\", {\n                  buttons: n,\n                  clientX: e.clientX,\n                  clientY: e.clientY,\n                  pageX: e.pageX,\n                  pageY: e.pageY,\n                  screenX: e.screenX,\n                  screenY: e.screenY\n                }), t.preventDefaultClick = !0;\n              }\n            }, t.delay);\n          }, t.initialDelay));\n        }\n\n        _stopRepeat(e) {\n          const t = this;\n          t.readonly || e && (\"pointercancel\" === e.type || e.originalEvent && \"pointercancel\" === e.originalEvent.type) || (t.$.setAttributeValue(\"active\", !1), t._repeatTimer && (clearInterval(t._repeatTimer), t._repeatTimer = null), t._initialTimer && (clearTimeout(t._initialTimer), t._initialTimer = null));\n        }\n\n        _touchmoveHandler(e) {\n          this.preventDefaultClick && e.cancelable && (e.preventDefault(), e.stopPropagation());\n        }\n\n        _overriddenHandler() {}\n\n      }), Smart(\"smart-toggle-button\", class extends Smart.Button {\n        static get properties() {\n          return {\n            checked: {\n              value: !1,\n              type: \"boolean?\"\n            },\n            falseContent: {\n              value: \"\",\n              reflectToAttribute: !1,\n              type: \"string\"\n            },\n            indeterminateContent: {\n              value: \"\",\n              reflectToAttribute: !1,\n              type: \"string\"\n            },\n            indeterminate: {\n              value: !1,\n              type: \"boolean\"\n            },\n            trueContent: {\n              value: \"\",\n              reflectToAttribute: !1,\n              type: \"string\"\n            },\n            indeterminateTemplate: {\n              value: null,\n              type: \"any\"\n            },\n            trueTemplate: {\n              value: null,\n              type: \"any\"\n            },\n            falseTemplate: {\n              value: null,\n              type: \"any\"\n            },\n            type: {\n              value: \"toggle\",\n              type: \"string\",\n              defaultReflectToAttribute: !0,\n              readonly: !0\n            }\n          };\n        }\n\n        static get listeners() {\n          return {\n            keydown: \"_keyHandler\",\n            keyup: \"_keyHandler\",\n            dragstart: \"_dragStartHandler\",\n            \"button.click\": \"_buttonClickHandler\",\n            \"button.mouseenter\": \"_buttonMouseEnterHandler\",\n            \"button.mouseleave\": \"_buttonMouseLeaveHandler\",\n            \"document.up\": \"_documentUpHandler\"\n          };\n        }\n\n        ready() {\n          super.ready(), this._setAriaState();\n        }\n\n        _setAriaState() {\n          const e = this,\n                t = e.checked;\n          null !== t ? e.setAttribute(\"aria-pressed\", t) : e.setAttribute(\"aria-pressed\", \"mixed\");\n        }\n\n        _buttonClickHandler() {}\n\n        _buttonMouseLeaveHandler() {\n          this.removeAttribute(\"hover\");\n        }\n\n        _buttonMouseEnterHandler() {\n          const e = this;\n          e.setAttribute(\"hover\", \"\"), e.disabled || e.readonly || \"hover\" !== e.clickMode || (e._changeCheckState(\"pointer\"), e.focus(), e._updateHidenInputNameAndValue());\n        }\n\n        _documentUpHandler(e) {\n          const t = this;\n          t._pressed && (t._pressed = !1, t.disabled || t.readonly || \"press\" === t.clickMode || \"pointercancel\" === e.originalEvent.type || (t._changeCheckState(\"pointer\"), t.focus(), t._updateHidenInputNameAndValue()));\n        }\n\n        _downHandler(e) {\n          const t = this;\n          t.disabled || t.readonly || (t.hasRippleAnimation && Smart.Utilities.Animation.Ripple.animate(t, e.pageX, e.pageY), t._pressed = !0, \"press\" !== t.clickMode && \"pressAndRelease\" !== t.clickMode || (t._changeCheckState(\"pointer\"), t.hasAttribute(\"smart-blazor\") ? t.$.dispatchEvent(new Event(\"click\")) : t.$.fireEvent(\"click\"), t._updateHidenInputNameAndValue()), \"press\" === t.clickMode && (e.preventDefault(), e.stopPropagation()));\n        }\n\n        _dragStartHandler(e) {\n          e.preventDefault();\n        }\n\n        _keyHandler(e) {\n          const t = this;\n\n          if (!0 !== t.disabled && !t.readonly && 32 === e.keyCode) {\n            if (\"keydown\" === e.type) return void e.preventDefault();\n            if (\"none\" === t.switchMode) return;\n            t._changeCheckState(\"keyboard\"), t._updateHidenInputNameAndValue();\n          }\n        }\n\n        _changeCheckState(e) {\n          const t = this;\n          let n = null;\n          null === t.checked ? t.checked = !0 : (n = t.checked, t.checked = !t.checked), t._handleTextSelection(), t.$.fireEvent(\"change\", {\n            value: t.checked,\n            oldValue: n,\n            changeType: e\n          }), t.checked ? t.$.fireEvent(\"checkValue\", {\n            changeType: e\n          }) : t.$.fireEvent(\"uncheckValue\", {\n            changeType: e\n          }), t._setAriaState();\n        }\n\n        _handleTextSelection() {\n          const e = this;\n          e.$.addClass(\"smart-unselectable\"), e.timer && clearTimeout(e.timer), e.timer = setTimeout(() => e.$.removeClass(\"smart-unselectable\"), 500);\n        }\n\n        propertyChangedHandler(e, t, n) {\n          super.propertyChangedHandler(e, t, n);\n          const a = this;\n          if (\"checked\" === e) return a.$.fireEvent(\"change\", {\n            value: n,\n            oldValue: t,\n            changeType: \"api\"\n          }), void a._setAriaState();\n\n          switch (e) {\n            case \"trueTemplate\":\n              a._handleTemplate(!0);\n\n              break;\n\n            case \"falseTemplate\":\n              a._handleTemplate(!1);\n\n              break;\n\n            case \"indeterminateTemplate\":\n              a._handleTemplate();\n\n          }\n        }\n\n        _htmlBindOnInitialization() {\n          const e = this;\n          e._bindContentProperty(\"trueContent\", \"smart-true-content\"), e._bindContentProperty(\"falseContent\", \"smart-false-content\"), e._bindContentProperty(\"indeterminateContent\", \"smart-indeterminate-content\");\n        }\n\n        _bindContentProperty(e, t) {\n          const n = this;\n          if (!n.$[e + \"Container\"]) return;\n          let a = document.createElement(\"div\");\n          a.innerHTML = n.innerHTML;\n          let r,\n              i = a.getElementsByClassName(t);\n          if (i.length > 0) for (let e = 0; e < i.length; e++) r = i[e];\n          \"\" === n[e] && (n[e] = void 0 === r ? \"\" : r.outerHTML), n.$[e + \"Container\"].innerHTML = n[e];\n        }\n\n        _updateContentProperties() {\n          const e = this;\n\n          function t(t) {\n            e.$[t + \"Container\"] && (e[t] = e.$[t + \"Container\"].innerHTML);\n          }\n\n          t(\"trueContent\"), t(\"falseContent\"), t(\"indeterminateContent\");\n        }\n\n        _updateHidenInputValue() {\n          const e = this;\n          if (!e.$.hiddenInput) return;\n          let t;\n          t = null === e.checked ? \"null\" : !1 === e.checked ? \"off\" : e.value || \"on\", e.$.hiddenInput.setAttribute(\"value\", t);\n        }\n\n        _updateHidenInputName() {\n          const e = this;\n          if (!e.$.hiddenInput) return;\n          let t = !1 === e.checked ? \"\" : e.name || \"\";\n          e.$.hiddenInput.setAttribute(\"name\", t);\n        }\n\n        _updateHidenInputNameAndValue() {\n          this._updateHidenInputName(), this._updateHidenInputValue();\n        }\n\n        _handleTemplate(e, t) {\n          const n = this;\n          let a, r, i;\n          if (!0 === e ? (a = n.trueTemplate, r = n.$.trueContentContainer, i = n.trueContent) : !1 === e ? (a = n.falseTemplate, r = n.$.falseContentContainer, i = n.falseContent) : (a = n.indeterminateTemplate, r = n.$.indeterminateContentContainer, i = n.indeterminateContent), t && (r.innerHTML = i || \"\"), null === a || !a) return;\n          if (\"function\" == typeof a) return void a(r, {\n            value: i\n          });\n          if (!(\"content\" in document.createElement(\"template\"))) return void n.error(n.localize(\"htmlTemplateNotSuported\", {\n            elementType: n.nodeName.toLowerCase()\n          }));\n          if (a = document.getElementById(a), null === a || !(\"content\" in a)) return void n.error(n.localize(\"invalidTemplate\", {\n            elementType: n.nodeName.toLowerCase(),\n            property: \"template\"\n          }));\n          const l = a.content,\n                o = l.childNodes.length,\n                s = /{{\\w+}}/g;\n          let u,\n              d = [];\n\n          for (let e = 0; e < o; e++) for (u = s.exec(l.childNodes[e].innerHTML); u;) d.push({\n            childNodeIndex: e,\n            bindingString: u[0]\n          }), u = s.exec(l.childNodes[e].innerHTML);\n\n          const c = d.length;\n          let p,\n              h,\n              m = document.importNode(a.content, !0);\n\n          for (let e = 0; e < c; e++) {\n            p = m.childNodes[d[e].childNodeIndex], h = d.length;\n\n            for (let t = 0; t < h; t++) p.innerHTML = p.innerHTML.replace(d[e].bindingString, i);\n          }\n\n          r.innerHTML = \"\";\n\n          for (let e = 0; e < m.childNodes.length; e++) m.childNodes[e].outerHTML && (r.innerHTML += m.childNodes[e].outerHTML);\n        }\n\n      });\n      /***/\n    },\n\n    /***/\n    8585:\n    /***/\n    () => {\n      Smart(\"smart-carousel\", class extends Smart.ContentElement {\n        static get properties() {\n          return {\n            adaptiveHeight: {\n              value: !1,\n              type: \"boolean\"\n            },\n            adaptiveAutoHeight: {\n              value: !1,\n              type: \"boolean\"\n            },\n            autoPlay: {\n              value: !1,\n              type: \"any\"\n            },\n            dataSource: {\n              value: [],\n              type: \"array\",\n              reflectToAttribute: !1\n            },\n            delay: {\n              value: 200,\n              type: \"number\"\n            },\n            displayMode: {\n              allowedValues: [\"default\", \"multiple\", \"3d\"],\n              value: \"default\",\n              type: \"string\"\n            },\n            disableItemClick: {\n              value: !1,\n              type: \"boolean\"\n            },\n            hideArrows: {\n              value: !1,\n              type: \"boolean\"\n            },\n            hideIndicators: {\n              value: !1,\n              type: \"boolean\"\n            },\n            indicatorTemplate: {\n              value: null,\n              type: \"any\"\n            },\n            interval: {\n              value: 5e3,\n              type: \"number\"\n            },\n            itemTemplate: {\n              value: null,\n              type: \"any\"\n            },\n            keyboard: {\n              value: !1,\n              type: \"boolean\"\n            },\n            loop: {\n              value: !1,\n              type: \"boolean\"\n            },\n            messages: {\n              value: {\n                en: {\n                  htmlTemplateNotSuported: \"{{elementType}}:  Browser doesn't support HTMLTemplate elements.\"\n                }\n              },\n              type: \"object\",\n              extend: !0\n            },\n            slideShow: {\n              value: !1,\n              type: \"boolean\"\n            },\n            swipe: {\n              value: !1,\n              type: \"boolean\"\n            },\n            wheel: {\n              value: !1,\n              type: \"boolean\"\n            }\n          };\n        }\n\n        static get listeners() {\n          return {\n            \"arrowLeft.click\": \"_handleArrowClick\",\n            \"arrowRight.click\": \"_handleArrowClick\",\n            \"indicatorsContainer.click\": \"_handleIndicatorsContainerClick\",\n            keydown: \"_handleKeyDown\",\n            swipeleft: \"_handleSwipe\",\n            swiperight: \"_handleSwipe\",\n            wheel: \"_handleMouseWheel\",\n            \"itemsContainer.click\": \"_handleItemClick\",\n            \"itemsContainer.transitionend\": \"_handleTransitionEnd\"\n          };\n        }\n\n        static get requires() {\n          return {\n            \"Smart.RepeatButton\": \"smart.button.js\"\n          };\n        }\n\n        static get styleUrls() {\n          return [\"smart.button.css\", \"smart.carousel.css\"];\n        }\n\n        get enableShadowDOM() {\n          const e = this,\n                t = Smart.EnableShadowDOM;\n          return e._isInShadowDOM ? !e._isInShadowDOM : e.isCompleted ? null !== e.shadowRoot : t;\n        }\n\n        template() {\n          return '<div id=\"container\" role=\"presentation\">\\n                    <div id=\"itemsContainer\" inner-h-t-m-l=\"[[innerHTML]]\" class=\"smart-items-container\" role=\"presentation\"><content></content></div>\\n                    <smart-repeat-button initial-delay=\"0\" right-to-left=\"[[rightToLeft]]\" delay=\"[[delay]]\" id=\"arrowLeft\" animation=\"[[animation]]\" unfocusable class=\"smart-arrow smart-arrow-left\" aria-label=\"Previous slide\"></smart-repeat-button>\\n                    <smart-repeat-button initial-delay=\"0\" right-to-left=\"[[rightToLeft]]\" delay=\"[[delay]]\" id=\"arrowRight\" animation=\"[[animation]]\" unfocusable class=\"smart-arrow smart-arrow-right\" aria-label=\"Next slide\"></smart-repeat-button>\\n                    <div id=\"indicatorsContainer\" class=\"smart-indicators-container\" role=\"tablist\"></div>\\n                </div>';\n        }\n\n        propertyChangedHandler(e, t, a) {\n          const n = this;\n\n          switch (super.propertyChangedHandler(e, t, a), e) {\n            case \"disabled\":\n              n._setFocusable();\n\n              break;\n\n            case \"dataSource\":\n              if (n._currentIndex = 0, n._generateIndicators(), n._generateItems(), n._handleIndicatorsState(0, 0), n._handleItemsState(0, 0), n._handle3dMode(0), !1 !== n.autoPlay) {\n                const e = parseInt(n.autoPlay);\n                e ? setTimeout(function () {\n                  n.play();\n                }, e) : n.play();\n              }\n\n              n._animationTrigger(n._currentIndex), (n.adaptiveHeight || n.adaptiveAutoHeight) && n._setAdaptiveHeight();\n              break;\n\n            case \"itemTemplate\":\n              n._generateItems(), n._handleItemsState(n._currentIndex, n._currentIndex + 1), (n.adaptiveHeight || n.adaptiveAutoHeight) && n._setAdaptiveHeight();\n              break;\n\n            case \"indicatorTemplate\":\n              n._generateIndicators(), n._handleIndicatorsState(n._currentIndex, n._currentIndex + 1);\n              break;\n\n            case \"interval\":\n              n.pause(), n.play();\n              break;\n\n            case \"loop\":\n              n._handleArrowsActiveState(n._currentIndex, n._currentIndex);\n\n              break;\n\n            case \"hideArrows\":\n              a || n._handleArrowsActiveState(n._currentIndex, n._currentIndex);\n              break;\n\n            case \"displayMode\":\n              \"multiple\" === t && n.$.itemsContainer.removeAttribute(\"style\");\n          }\n        }\n\n        render() {\n          const e = this;\n\n          if (e.setAttribute(\"role\", \"region\"), e.setAttribute(\"aria-roledescription\", \"carousel\"), e._setInitialState(), e._generateIndicators(), e._generateItems(), e._handleIndicatorsState(0, 0), e._handleItemsState(0, 0), e._handle3dMode(0), !1 !== e.autoPlay) {\n            const t = parseInt(e.autoPlay);\n            t ? setTimeout(function () {\n              e.play();\n            }, t) : e.play();\n          }\n\n          e._setFocusable(), e._animationTrigger(e._currentIndex), e._handleArrowsActiveState(0, e._currentIndex), (e.adaptiveHeight || e.adaptiveAutoHeight) && (window.addEventListener(\"resize\", () => {\n            e._setAdaptiveHeight();\n          }), e._setAdaptiveHeight()), super.render();\n        }\n\n        _setAdaptiveHeight() {\n          const e = this;\n          let t = 10;\n          (e.adaptiveHeight || e.adaptiveAutoHeight) && (e._items.forEach(a => {\n            const n = a.querySelector(\"img\");\n            n && (n.onload = () => {\n              e.classList.remove(\"smart-calculated-height\"), e.offsetHeight < a.children[0].offsetHeight && (e.style.height = a.children[0].offsetHeight + \"px\"), e.classList.add(\"smart-calculated-height\");\n            }), a.children[0].offsetHeight > t && (t = a.children[0].offsetHeight);\n          }), e.style.height = t + \"px\", e.classList.add(\"smart-calculated-height\"));\n        }\n\n        _setAdaptiveAutoHeight() {\n          const e = this;\n          let t = 10;\n          e._items.forEach(e => {\n            e.classList.contains(\"smart-active\") && (t = e.children[0].offsetHeight);\n          }), e.style.height = t + \"px\", e.classList.add(\"smart-calculated-height\");\n        }\n\n        next() {\n          const e = this,\n                t = e.dataSource.length;\n          if (e.disabled || 0 === t) return;\n          let a = e._currentIndex;\n          a = e.loop ? a >= t - 1 ? 0 : a + 1 : a >= t - 1 ? a : a + 1, e._goToItem(a);\n        }\n\n        pause() {\n          this._handleRotation(), this._rotate = !1;\n        }\n\n        slideTo(e) {\n          const t = this;\n          e = e ? parseInt(e) : 0, t.disabled || e < 0 || e > t._items.length || t._goToItem(e);\n        }\n\n        prev() {\n          const e = this,\n                t = e.dataSource.length;\n          if (e.disabled || 0 === t) return;\n          let a = e._currentIndex;\n          a = e.loop ? a <= 0 ? t - 1 : a - 1 : a <= 0 ? 0 : a - 1, e._goToItem(a);\n        }\n\n        play() {\n          const e = this;\n          !e.disabled && e.slideShow && (e._rotationInterval && clearInterval(e._rotationInterval), e._handleRotation(!0), e._rotate = !0);\n        }\n\n        _animationTrigger(e) {\n          const t = this;\n\n          for (let a = 0; a < t._items.length; a++) a !== e && t._items[a].classList.add(\"smart-animate-trigger\");\n        }\n\n        _handle3dMode(e) {\n          const t = this,\n                a = t.dataSource.length;\n\n          if (!t.disabled && a && \"3d\" === t.displayMode) {\n            e = e || 0;\n\n            for (let n = 0; n < a; n++) {\n              const a = (n - e) * (t.rightToLeft ? -1 : 1);\n              a ? t._items[n].setAttribute(\"position\", a) : t._items[n].removeAttribute(\"position\");\n            }\n          }\n        }\n\n        _handleArrowsActiveState(e) {\n          const t = this,\n                a = t.dataSource.length;\n          t.loop ? t.$.arrowLeft.disabled = t.$.arrowRight.disabled = !1 : t.rightToLeft ? (t.$.arrowRight.disabled = 0 === e, t.$.arrowLeft.disabled = e === a - 1) : (t.$.arrowLeft.disabled = 0 === e, t.$.arrowRight.disabled = e === a - 1);\n        }\n\n        _handleArrowClick(e) {\n          const t = this,\n                a = t._currentIndex;\n          t.disabled || (t.rightToLeft ? t.$.arrowLeft.contains(e.target) ? t.next() : t.prev() : t.$.arrowLeft.contains(e.target) ? t.prev() : t.next(), t._changeEvent(a, t._currentIndex));\n        }\n\n        _handleDefaultInnerHTML() {\n          const e = this;\n\n          if (!(e.dataSource && e.dataSource.length > 0) && e.$.itemsContainer.innerHTML.indexOf(\"<ul\") >= 0) {\n            const t = e.$.itemsContainer.getElementsByTagName(\"ul\")[0].getElementsByTagName(\"li\");\n\n            for (let a = 0; a < t.length; a++) {\n              const n = {\n                HTMLcontent: t[a].innerHTML\n              };\n              e.dataSource.push(n);\n            }\n          }\n        }\n\n        _handleIndicatorsState(e, t) {\n          const a = this;\n          a.disabled || 0 === a._indicators.length || !e && 0 !== e || !t && 0 !== t || (e !== t && (a._indicators[e].classList.remove(\"smart-active\"), a._indicators[e].setAttribute(\"aria-selected\", !1)), a._indicators[t].classList.add(\"smart-active\"), a._indicators[t].setAttribute(\"aria-selected\", !0));\n        }\n\n        _handleItemClick(e) {\n          const t = this,\n                a = e.target.closest(\".smart-carousel-item\");\n          if (t.disabled || !a || \"3d\" !== t.displayMode || t.disableItemClick) return;\n          const n = parseInt(a.getAttribute(\"item-id\")),\n                i = parseInt(a.getAttribute(\"position\"));\n          Math.abs(i) > 3 || t._goToItem(n);\n        }\n\n        _handleItemsState(e, t) {\n          const a = this;\n          a.disabled || 0 === a._items.length || !e && 0 !== e || !t && 0 !== t || (e !== t && (a._items[e].classList.remove(\"smart-active\"), a._items[e].classList.add(\"smart-out\")), a._items[t].classList.add(\"smart-active\"));\n        }\n\n        _handleIndicatorsContainerClick(e) {\n          const t = this,\n                a = e.target.closest(\".smart-indicator\"),\n                n = t._currentIndex;\n          if (t.disabled || !a) return;\n          const i = parseInt(a.getAttribute(\"indicator-id\"));\n          n !== i && (t._goToItem(i), t._changeEvent(n, t._currentIndex));\n        }\n\n        _handleMultipleMode(e) {\n          const t = this;\n          if (\"multiple\" !== t.displayMode) return;\n          const a = t._items[e].offsetWidth,\n                n = t.$.container.offsetWidth,\n                i = t.$.itemsContainer.offsetWidth;\n          let r = 0;\n          if (0 !== e) {\n            if (e !== t._items.length - 1) {\n              for (let a = 0; a < e; a++) r += t._items[e].offsetWidth;\n\n              r + a / 2 >= n / 2 && r + a < i && (t.$.itemsContainer.style.marginLeft = \"-\" + (r + a / 2 - n / 2) + \"px\");\n            } else t.$.itemsContainer.style.marginLeft = \"-\" + (i - n) + \"px\";\n          } else t.$.itemsContainer.style.marginLeft = \"0px\";\n        }\n\n        _changeEvent(e, t) {\n          if (e === t) return;\n          const a = this;\n          a.onIndexChange ? a.onIndexChange(t) : (a.$.fireEvent(\"changing\", {\n            index: t,\n            previousIndex: e\n          }), a.hasAnimation && \"default\" !== a.displayMode || a.$.fireEvent(\"change\", {\n            index: t,\n            previousIndex: e\n          }));\n        }\n\n        _handleKeyDown(e) {\n          const t = this,\n                a = e.key,\n                n = t._currentIndex;\n\n          if (!t.disabled && t.keyboard && -1 !== [\"ArrowLeft\", \"ArrowDown\", \"ArrowRight\", \"ArrowUp\", \"Home\", \"End\", \" \", \"Enter\"].indexOf(a)) {\n            switch (a) {\n              case \"ArrowLeft\":\n              case \"ArrowDown\":\n                t.rightToLeft ? t.next() : t.prev();\n                break;\n\n              case \"ArrowUp\":\n              case \"ArrowRight\":\n                t.rightToLeft ? t.prev() : t.next();\n                break;\n\n              case \"Home\":\n                t._goToItem(0);\n\n                break;\n\n              case \"End\":\n                t._goToItem(t.dataSource.length - 1);\n\n                break;\n\n              case \" \":\n                t._rotate ? t.pause() : t.play();\n                break;\n\n              case \"Enter\":\n                t.play();\n            }\n\n            t._changeEvent(n, t._currentIndex);\n          }\n        }\n\n        _handleMouseWheel(e) {\n          const t = this,\n                a = t._currentIndex;\n          !t.disabled && t.wheel && document.activeElement === t && (e.stopPropagation(), e.preventDefault(), e.deltaY > 0 ? t.next() : t.prev(), t._changeEvent(a, t._currentIndex));\n        }\n\n        _handleRotation(e) {\n          const t = this;\n          e ? t._rotationInterval = setInterval(function () {\n            t.slideShow && t.next();\n          }, t.interval) : clearInterval(t._rotationInterval);\n        }\n\n        _handleSwipe(e) {\n          const t = this;\n          !t.disabled && t.swipe && (e.stopPropagation(), e.preventDefault(), \"swipeleft\" === e.type ? t.prev() : t.next());\n        }\n\n        _generateIndicator(e) {\n          const t = this,\n                a = document.createElement(\"span\"),\n                n = e || 0;\n\n          if (t.indicatorTemplate) {\n            const e = t._validateTemplate(t.indicatorTemplate);\n\n            a.innerHTML = t._processItemTemplate(e.content, t.dataSource[n]);\n          }\n\n          return a.setAttribute(\"role\", \"tab\"), a.setAttribute(\"aria-selected\", !1), a.classList.add(\"smart-indicator\"), a.setAttribute(\"indicator-id\", n), a;\n        }\n\n        _generateIndicators() {\n          const e = this,\n                t = e.dataSource.length;\n          let a = [],\n              n = document.createDocumentFragment();\n\n          for (let i = 0; i < t; i++) {\n            const t = e._generateIndicator(i);\n\n            a.push(t), n.appendChild(t);\n          }\n\n          e._indicators = a;\n          const i = e.$.indicatorsContainer;\n\n          for (; i.firstChild;) i.removeChild(i.firstChild);\n\n          i.appendChild(n);\n        }\n\n        _generateItem(e) {\n          const t = this,\n                a = e || 0,\n                n = t.dataSource[a],\n                i = document.createElement(\"div\");\n\n          if (i.id = t.id + \"Slide\" + e, t.itemTemplate) {\n            const e = t._validateTemplate(t.itemTemplate);\n\n            i.innerHTML = t._processItemTemplate(e.content, t.dataSource[a]);\n          } else \"string\" == typeof n ? i.style.backgroundImage = 'url(\"' + n + '\")' : i.innerHTML = `<div class=\"smart-carousel-item-container\" style=\"background-image:url('${n.image || \"\"}')\" role=\"presentation\">\\n                        <h2 id=\"${i.id + \"Label\"}\" class=\"smart-carousel-item-label\">${n.label || \"\"}</h2 >\\n                        <p class=\"smart-carousel-item-content\">${n.content || \"\"}</p>\\n                    </div>\\n                    <div class=\"smart-carousel-html-content\">${n.HTMLcontent || \"\"}</div>\\n                </div>`;\n\n          return n.label ? (i.setAttribute(\"aria-labelledby\", i.id + \"Label\"), t._indicators[e].setAttribute(\"aria-labelledby\", i.id + \"Label\")) : (i.setAttribute(\"aria-label\", \"Slide \" + e), t._indicators[e].setAttribute(\"aria-label\", \"Slide \" + e)), t._indicators[e].setAttribute(\"aria-controls\", i.id), i.setAttribute(\"role\", \"tabpanel\"), i.classList.add(\"smart-carousel-item\"), i.setAttribute(\"item-id\", a), i;\n        }\n\n        _processItemTemplate(e, t) {\n          const a = e.match(/{{\\w+}}/g);\n          let n = e;\n          return a && 0 !== a.length ? (a.forEach(function (e) {\n            const a = e.replace(\"{{\", \"\").replace(\"}}\", \"\");\n            n = n.replace(e, t[a] || \"\");\n          }), n) : n;\n        }\n\n        _generateItems() {\n          const e = this,\n                t = e.dataSource.length;\n          let a = [],\n              n = document.createDocumentFragment();\n\n          for (let i = 0; i < t; i++) {\n            const t = e._generateItem(i);\n\n            a.push(t), n.appendChild(t);\n          }\n\n          e._items = a;\n          const i = e.$.itemsContainer;\n\n          for (; i.firstChild;) i.removeChild(i.firstChild);\n\n          i.appendChild(n);\n        }\n\n        _goToItem(e, t) {\n          const a = this,\n                n = a.dataSource.length,\n                i = a._currentIndex;\n          let r = e;\n          e < 0 ? r = 0 : e > n - 1 && (r = n - 1), a._removeFadeOut(), a._animationTrigger(), a._handleIndicatorsState(i, r), a._handleItemsState(i, r), a._currentIndex = r, t && a._changeEvent(i, r), a._handle3dMode(r), a._handleMultipleMode(r), a._handleArrowsActiveState(r, i), a.adaptiveAutoHeight && a._setAdaptiveAutoHeight();\n        }\n\n        _setFocusable() {\n          const e = this;\n          if (e.disabled || e.unfocusable) return e.removeAttribute(\"tabindex\"), void (e.tabIndex = -1);\n          let t = e.tabIndex > 0 ? e.tabIndex : 0;\n          e.setAttribute(\"tabindex\", t), e.tabIndex = t;\n        }\n\n        _setInitialState() {\n          const e = this;\n          e._currentIndex = 0, e._indicators = [], e._items = [], e._rotate = !1, e._handleDefaultInnerHTML();\n        }\n\n        _validateTemplate(e) {\n          const t = this;\n          let a = \"\",\n              n = !1;\n          return \"function\" == typeof e && (a = e()), \"content\" in document.createElement(\"template\") ? (a = e instanceof HTMLElement || (e = document.getElementById(e)) ? e.innerHTML : \"\", /{{\\w+}}/g.exec(a) && (n = !0), {\n            content: a,\n            hasBindings: n\n          }) : (t.error(t.localize(\"htmlTemplateNotSuported\", {\n            elementType: t.nodeName.toLowerCase()\n          })), void (t.itemTemplate = null));\n        }\n\n        _handleTransitionEnd(e) {\n          if (!e.target.classList.contains(\"smart-carousel-item\") || e.target.getAttribute(\"position\")) return;\n          const t = this,\n                a = e.target.getAttribute(\"item-id\");\n          t._lastTransitionEndId !== a && (t._removeFadeOut(), this.$.fireEvent(\"change\", {\n            index: a,\n            previousIndex: t._lastTransitionEndId\n          }), t._lastTransitionEndId = a);\n        }\n\n        _removeFadeOut() {\n          const e = this.$.itemsContainer.getElementsByClassName(\"smart-out\");\n          if (e.length) for (let t = 0; t < e.length; t++) e[t].classList.remove(\"smart-out\");\n        }\n\n      });\n      /***/\n    },\n\n    /***/\n    6321:\n    /***/\n    () => {\n      !function () {\n        const e = \"9.1.27\",\n              t = [];\n        let n = \"Smart\";\n\n        if (window[n] && window[n].Version) {\n          if (window[n].Version === e) return;\n          if (window[n].Version !== e) n += e;else {\n            let e = 2;\n\n            for (; window[n];) n += e.toString(), e++;\n          }\n        }\n\n        const o = navigator.userAgent.indexOf(\"Edge\") > -1 && navigator.appVersion.indexOf(\"Edge\") > -1;\n        document.elementsFromPoint || (document.elementsFromPoint = document.msElementsFromPoint);\n\n        class r {\n          static isBoolean(e) {\n            return \"boolean\" == typeof e;\n          }\n\n          static isFunction(e) {\n            return !!(e && e.constructor && e.call && e.apply);\n          }\n\n          static isArray(e) {\n            return Array.isArray(e);\n          }\n\n          static isObject(e) {\n            return e && (\"object\" == typeof e || this.isFunction(e)) || !1;\n          }\n\n          static isDate(e) {\n            return e instanceof Date;\n          }\n\n          static isString(e) {\n            return \"string\" == typeof e;\n          }\n\n          static isNumber(e) {\n            return \"number\" == typeof e;\n          }\n\n          static getType(e) {\n            const t = this,\n                  n = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"Object\"].find(n => {\n              if (t[\"is\" + n](e)) return n;\n            });\n            return n ? n.toLowerCase() : void 0;\n          }\n\n        }\n\n        class i {\n          static animate(e, t, o, r) {\n            const i = e;\n            if (!i || i instanceof HTMLElement == 0) return;\n\n            if (0 === i.getElementsByClassName(\"smart-ripple\").length) {\n              const e = document.createElement(\"span\");\n              e.classList.add(\"smart-ripple\"), e.setAttribute(\"role\", \"presentation\");\n              let t = !0,\n                  o = null;\n\n              if (window[n].EnableShadowDOM && i.enableShadowDOM && !0 !== i.isInShadowDOM) {\n                for (let e = 0; e < i.shadowRoot.host.shadowRoot.children.length; e++) \"link\" !== i.shadowRoot.host.shadowRoot.children[e].tagName.toLowerCase() && (o = i.shadowRoot.host.shadowRoot.children[e]);\n\n                i.shadowRoot.host.shadowRoot.querySelector(\".smart-ripple\") && (t = !1);\n              } else o = i.firstElementChild;\n\n              t && (o && !o.noRipple && o.offsetHeight > 0 ? o.appendChild(e) : i.appendChild(e));\n            }\n\n            let s = null;\n            if (s = window[n].EnableShadowDOM && i.shadowRoot ? i.shadowRoot.host.shadowRoot.querySelector(\".smart-ripple\") : i.getElementsByClassName(\"smart-ripple\")[0], !s) return;\n            s.innerHTML = \"\", s.classList.remove(\"smart-animate\"), s.style.height = s.style.width = Math.max(i.offsetHeight, i.offsetWidth) + \"px\";\n            const a = window.getComputedStyle(s.parentElement),\n                  l = parseInt(a.borderLeftWidth) || 0,\n                  d = parseInt(a.borderTopWidth) || 0,\n                  c = i.getBoundingClientRect(),\n                  u = t - (c.left + window.pageXOffset) - s.offsetWidth / 2 - l,\n                  p = o - (c.top + window.pageYOffset) - s.offsetHeight / 2 - d;\n            s.style.left = u + \"px\", s.style.top = p + \"px\", s.classList.add(\"smart-animate\"), s.addEventListener(\"animationend\", function e() {\n              s.parentElement && s.parentElement.removeChild(s), r && r(), s.removeEventListener(\"animationend\", e), s.removeEventListener(\"animationcancel\", e);\n            }), s.addEventListener(\"animationcancel\", function e() {\n              s.parentElement && s.parentElement.removeChild(s), r && r(), s.removeEventListener(\"animationcancel\", e), s.removeEventListener(\"animationend\", e);\n            });\n          }\n\n        }\n\n        class s {\n          static easeInQuad(e, t, n, o) {\n            return n * (e /= o) * e + t;\n          }\n\n          static easeOutQuad(e, t, n, o) {\n            return -n * (e /= o) * (e - 2) + t;\n          }\n\n          static easeInOutQuad(e, t, n, o) {\n            return (e /= o / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t;\n          }\n\n          static easeInCubic(e, t, n, o) {\n            return n * (e /= o) * e * e + t;\n          }\n\n          static easeOutCubic(e, t, n, o) {\n            return n * ((e = e / o - 1) * e * e + 1) + t;\n          }\n\n          static easeInOutCubic(e, t, n, o) {\n            return (e /= o / 2) < 1 ? n / 2 * e * e * e + t : n / 2 * ((e -= 2) * e * e + 2) + t;\n          }\n\n          static easeInQuart(e, t, n, o) {\n            return n * (e /= o) * e * e * e + t;\n          }\n\n          static easeOutQuart(e, t, n, o) {\n            return -n * ((e = e / o - 1) * e * e * e - 1) + t;\n          }\n\n          static easeInOutQuart(e, t, n, o) {\n            return (e /= o / 2) < 1 ? n / 2 * e * e * e * e + t : -n / 2 * ((e -= 2) * e * e * e - 2) + t;\n          }\n\n          static easeInQuint(e, t, n, o) {\n            return n * (e /= o) * e * e * e * e + t;\n          }\n\n          static easeOutQuint(e, t, n, o) {\n            return n * ((e = e / o - 1) * e * e * e * e + 1) + t;\n          }\n\n          static easeInOutQuint(e, t, n, o) {\n            return (e /= o / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t;\n          }\n\n          static easeInSine(e, t, n, o) {\n            return -n * Math.cos(e / o * (Math.PI / 2)) + n + t;\n          }\n\n          static easeOutSine(e, t, n, o) {\n            return n * Math.sin(e / o * (Math.PI / 2)) + t;\n          }\n\n          static easeInOutSine(e, t, n, o) {\n            return -n / 2 * (Math.cos(Math.PI * e / o) - 1) + t;\n          }\n\n          static easeInExpo(e, t, n, o) {\n            return 0 === e ? t : n * Math.pow(2, 10 * (e / o - 1)) + t;\n          }\n\n          static easeOutExpo(e, t, n, o) {\n            return e === o ? t + n : n * (1 - Math.pow(2, -10 * e / o)) + t;\n          }\n\n          static easeInOutExpo(e, t, n, o) {\n            return 0 === e ? t : e === o ? t + n : (e /= o / 2) < 1 ? n / 2 * Math.pow(2, 10 * (e - 1)) + t : n / 2 * (2 - Math.pow(2, -10 * --e)) + t;\n          }\n\n          static easeInCirc(e, t, n, o) {\n            return -n * (Math.sqrt(1 - (e /= o) * e) - 1) + t;\n          }\n\n          static easeOutCirc(e, t, n, o) {\n            return n * Math.sqrt(1 - (e = e / o - 1) * e) + t;\n          }\n\n          static easeInOutCirc(e, t, n, o) {\n            return (e /= o / 2) < 1 ? -n / 2 * (Math.sqrt(1 - e * e) - 1) + t : n / 2 * (Math.sqrt(1 - (e -= 2) * e) + 1) + t;\n          }\n\n          static easeInElastic(e, t, n, o) {\n            let r = 1.70158,\n                i = 0,\n                s = n;\n            return 0 === e ? t : 1 == (e /= o) ? t + n : (i || (i = .3 * o), s < Math.abs(n) ? (s = n, r = i / 4) : r = i / (2 * Math.PI) * Math.asin(n / s), -s * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * o - r) * (2 * Math.PI) / i) + t);\n          }\n\n          static easeOutElastic(e, t, n, o) {\n            let r = 1.70158,\n                i = 0,\n                s = n;\n            return 0 === e ? t : 1 == (e /= o) ? t + n : (i || (i = .3 * o), s < Math.abs(n) ? (s = n, r = i / 4) : r = i / (2 * Math.PI) * Math.asin(n / s), s * Math.pow(2, -10 * e) * Math.sin((e * o - r) * (2 * Math.PI) / i) + n + t);\n          }\n\n          static easeInOutElastic(e, t, n, o) {\n            let r = 1.70158,\n                i = 0,\n                s = n;\n            return 0 === e ? t : 2 == (e /= o / 2) ? t + n : (i || (i = o * (.3 * 1.5)), s < Math.abs(n) ? (s = n, r = i / 4) : r = i / (2 * Math.PI) * Math.asin(n / s), e < 1 ? s * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * o - r) * (2 * Math.PI) / i) * -.5 + t : s * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * o - r) * (2 * Math.PI) / i) * .5 + n + t);\n          }\n\n          static easeInBack(e, t, n, o, r) {\n            return void 0 === r && (r = 1.70158), n * (e /= o) * e * ((r + 1) * e - r) + t;\n          }\n\n          static easeOutBack(e, t, n, o, r) {\n            return void 0 === r && (r = 1.70158), n * ((e = e / o - 1) * e * ((r + 1) * e + r) + 1) + t;\n          }\n\n          static easeInOutBack(e, t, n, o, r) {\n            return void 0 === r && (r = 1.70158), (e /= o / 2) < 1 ? n / 2 * (e * e * ((1 + (r *= 1.525)) * e - r)) + t : n / 2 * ((e -= 2) * e * ((1 + (r *= 1.525)) * e + r) + 2) + t;\n          }\n\n          static easeInBounce(e, t, n, o) {\n            return n - this.easeOutBounce(o - e, 0, n, o) + t;\n          }\n\n          static easeOutBounce(e, t, n, o) {\n            return (e /= o) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t;\n          }\n\n          static easeInOutBounce(e, t, n, o) {\n            return e < o / 2 ? .5 * this.easeInBounce(2 * e, 0, n, o) + t : .5 * this.easeOutBounce(2 * e - o, 0, n, o) + .5 * n + t;\n          }\n\n        }\n\n        class a {\n          static get isMobile() {\n            const e = /(iphone|ipod|ipad|android|iemobile|blackberry|bada)/.test(window.navigator.userAgent.toLowerCase());\n            return e || [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n          }\n\n          static get Browser() {\n            let e;\n\n            const t = function (t) {\n              let n = t.indexOf(e);\n              if (-1 === n) return;\n              const o = t.indexOf(\"rv:\");\n              return \"Trident\" === e && -1 !== o ? parseFloat(t.substring(o + 3)) : parseFloat(t.substring(n + e.length + 1));\n            };\n\n            let n = {};\n            return n[function () {\n              const t = [{\n                string: navigator.userAgent,\n                subString: \"Edge\",\n                identity: \"Edge\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"MSIE\",\n                identity: \"IE\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"Trident\",\n                identity: \"IE\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"Firefox\",\n                identity: \"Firefox\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"Opera\",\n                identity: \"Opera\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"OPR\",\n                identity: \"Opera\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"Chrome\",\n                identity: \"Chrome\"\n              }, {\n                string: navigator.userAgent,\n                subString: \"Safari\",\n                identity: \"Safari\"\n              }];\n\n              for (let n = 0; n < t.length; n++) {\n                let o = t[n].string;\n                if (e = t[n].subString, -1 !== o.indexOf(t[n].subString)) return t[n].identity;\n              }\n\n              return \"Other\";\n            }()] = !0, n.version = t(navigator.userAgent) || t(navigator.appVersion) || \"Unknown\", n;\n          }\n\n          static toCamelCase(e) {\n            return e.replace(/-([a-z])/g, function (e) {\n              return e[1].toUpperCase();\n            });\n          }\n\n          static toDash(e) {\n            return e.split(/(?=[A-Z])/).join(\"-\").toLowerCase();\n          }\n\n          static unescapeHTML(e) {\n            return new DOMParser().parseFromString(e, \"text/html\").documentElement.textContent;\n          }\n\n          static escapeHTML(e) {\n            const t = {\n              \"&\": \"&amp;\",\n              \"<\": \"&lt;\",\n              \">\": \"&gt;\",\n              '\"': \"&quot;\",\n              \"'\": \"&#39;\",\n              \"/\": \"&#x2F;\",\n              \"`\": \"&#x60;\",\n              \"=\": \"&#x3D;\"\n            };\n            return String(e).replace(/[&<>\"'`=\\/]/g, e => t[e]);\n          }\n\n          static sanitizeHTML(e) {\n            if (e && (e.indexOf(\"onclick\") >= 0 || e.indexOf(\"onload\") >= 0 || e.indexOf(\"onerror\") >= 0)) return this.escapeHTML(e);\n            const t = new RegExp(\"<s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)[^>]*>(.*?)<s*/s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)>\", \"ig\");\n            return String(e).replace(t, e => this.escapeHTML(e));\n          }\n\n          static createGUID() {\n            function e() {\n              return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n            }\n\n            return e() + e() + \"-\" + e() + \"-\" + e() + \"-\" + e() + \"-\" + e() + e() + e();\n          }\n\n          static getScriptLocation() {\n            return \"./\" !== window[n].BaseUrl ? window[n].BaseUrl : function () {\n              if (document.currentScript) {\n                let e = document.currentScript.src,\n                    t = e.lastIndexOf(\"/\");\n                return e = e.substring(0, t), e;\n              }\n\n              const e = new Error();\n              let t = \"(\",\n                  n = \")\";\n              if (Smart.Utilities.Core.Browser.Safari && (t = \"@\", n = \"\\n\"), e.fileName) return e.fileName.replace(\"/smart.element.js\", \"\");\n              let o = e.stack.split(t);\n              return o = o[1], o = o.split(n)[0], o = o.split(\":\"), o.splice(-2, 2), o = o.join(\":\"), o.replace(\"/smart.element.js\", \"\");\n            }();\n          }\n\n          static CSSVariablesSupport() {\n            return window.CSS && window.CSS.supports && window.CSS.supports(\"(--fake-var: 0)\");\n          }\n\n          static assign(e, t) {\n            const n = e => e && \"object\" == typeof e && !Array.isArray(e) && null !== e;\n\n            let o = Object.assign({}, e);\n            return n(e) && n(t) && Object.keys(t).forEach(r => {\n              n(t[r]) ? r in e ? o[r] = this.assign(e[r], t[r]) : Object.assign(o, {\n                [r]: t[r]\n              }) : Object.assign(o, {\n                [r]: t[r]\n              });\n            }), o;\n          }\n\n          static html(e, t) {\n            const n = this;\n            let o = \"\",\n                r = e.childNodes;\n\n            if (!t) {\n              for (let e, t = 0, i = r.length; t < i && (e = r[t]); t++) {\n                const t = [\"strong\"];\n\n                if (e instanceof HTMLElement || e.tagName && t.indexOf(e.tagName.toLowerCase()) >= 0) {\n                  const t = e.tagName.toLowerCase(),\n                        r = e.attributes;\n                  let i = \"<\" + t;\n\n                  for (let e, t = 0; e = r[t]; t++) i += \" \" + e.name + '=\"' + e.value.replace(/[&\\u00A0\"]/g, y.Core.escapeHTML) + '\"';\n\n                  i += \">\", [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"][t] && (o += i), o = o + i + n.html(e) + \"</\" + t + \">\";\n                } else {\n                  if (8 === e.nodeType) continue;\n                  o += e.textContent.replace(/[&\\u00A0<>]/g, y.Core.escapeHTML);\n                }\n              }\n\n              return o;\n            }\n\n            {\n              const n = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi;\n              e.innerHTML = t.replace(n, \"<$1></$2>\");\n            }\n          }\n\n        }\n\n        let l = [];\n\n        class d {\n          static watch(e) {\n            switch (e.nodeName.toLowerCase()) {\n              case \"smart-grid\":\n              case \"smart-kanban\":\n              case \"smart-table\":\n              case \"smart-pivot-table\":\n              case \"smart-scheduler\":\n              case \"smart-tabs\":\n              case \"smart-card-view\":\n              case \"smart-list-box\":\n              case \"smart-combo-box\":\n              case \"smart-drop-down-list\":\n              case \"smart-calendar\":\n              case \"smart-gauge\":\n              case \"smart-numeric-text-box\":\n              case \"smart-menu\":\n              case \"smart-tree\":\n                l.push(e);\n                break;\n\n              default:\n                return;\n            }\n\n            d.start();\n          }\n\n          static start() {\n            d.isStarted || (d.isStarted = !0, d.interval && clearInterval(d.interval), 0 === l.length || document.hidden ? d.isStarted = !1 : d.interval = setInterval(function () {\n              d.observe();\n            }, 100));\n          }\n\n          static stop() {\n            d.isStarted = !1, d.interval && clearInterval(d.interval);\n          }\n\n          static observeElement(e) {\n            const t = e;\n            if (\"test\" === window.Smart.Mode || document.hidden) return void (d.interval && clearInterval(d.interval));\n            let n = e._computedStyle || \"resize\" !== t.hasStyleObserver ? document.defaultView.getComputedStyle(t, null) : {},\n                o = !0,\n                r = \"resize\" !== t.hasStyleObserver ? [\"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\", \"borderBottomWidth\", \"display\", \"visibility\", \"font-size\", \"font-family\", \"font-style\", \"font-weight\", \"max-height\", \"min-height\", \"max-width\", \"min-width\", \"overflow\", \"overflow-x\", \"overflow-y\"] : [];\n\n            if (e.styleProperties && (r = r.concat(e.styleProperties)), e.observableStyleProperties && (r = e.observableStyleProperties), !t._styleInfo) {\n              t._styleInfo = [];\n\n              for (let e = 0; e < r.length; e++) {\n                const o = r[e],\n                      i = o.startsWith(\"--\") ? n.getPropertyValue(o) : n[o];\n                t._styleInfo[o] = i;\n              }\n\n              return;\n            }\n\n            if (e.isHidden || \"none\" !== n.display && (0 !== e.offsetWidth && 0 !== e.offsetHeight || (e.isHidden = !0)), e.isHidden) {\n              if (e.visibilityChangedHandler(), e.isHidden) return;\n              o = !1;\n            }\n\n            let i = [];\n\n            for (let e = 0; e < r.length; e++) {\n              const o = r[e],\n                    s = o.startsWith(\"--\") ? n.getPropertyValue(o) : n[o];\n              t._styleInfo[o] !== s && (i[o] = {\n                oldValue: t._styleInfo[o],\n                value: s\n              }, i.length++), t._styleInfo[o] = s;\n            }\n\n            i.length > 0 && (t.$.fireEvent(\"styleChanged\", {\n              styleProperties: i\n            }, {\n              bubbles: !1,\n              cancelable: !0\n            }), i.display && o && t.$.fireEvent(\"resize\", t, {\n              bubbles: !1,\n              cancelable: !0\n            }));\n          }\n\n          static observe() {\n            for (let e = 0; e < l.length; e++) {\n              const t = l[e];\n              this.observeElement(t);\n            }\n          }\n\n          static unwatch(e) {\n            d.stop();\n            const t = l.indexOf(e);\n            -1 !== t && l.splice(t, 1), d.start();\n          }\n\n        }\n\n        let c = [];\n        const u = [],\n              p = [\"resize\", \"down\", \"up\", \"move\", \"tap\", \"taphold\", \"swipeleft\", \"swiperight\", \"swipetop\", \"swipebottom\"];\n\n        class h {\n          constructor(e) {\n            const t = this;\n            t.target = e, t.$target = new f(e), t.$document = e.$document ? e.$document : new f(document), t.id = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();\n            let n = {\n              handlers: {},\n              boundEventTypes: [],\n              listen: t.listen.bind(t),\n              unlisten: t.unlisten.bind(t)\n            };\n            return t.tapHoldDelay = 750, t.swipeMin = 10, t.swipeMax = 5e3, t.swipeDelay = 1e3, t.tapHoldDelay = 750, t.inputEventProperties = [\"clientX\", \"clientY\", \"pageX\", \"pageY\", \"screenX\", \"screenY\"], p.forEach(e => {\n              n[e] = t => {\n                n.handlers[e] = t;\n              }, t[e] = e => {\n                if (!n.handlers[e.type]) {\n                  if ((\"mousemove\" === e.type || \"pointermove\" === e.type || \"touchmove\" === e.type) && n.handlers.move) {\n                    const o = t.createEvent(e, \"move\");\n                    n.handlers.move(o);\n                  }\n\n                  return !0;\n                }\n\n                return n.handlers[e.type](e);\n              };\n            }), t.listen(), t.handlers = n.handlers, n;\n          }\n\n          listen(e) {\n            const t = this;\n            if (\"resize\" === e && t.target !== document && t.target !== window && !1 !== t.target.hasResizeObserver) if (Smart.Utilities.Core.Browser.Firefox) {\n              if (!t.target.resizeObserver) {\n                let e,\n                    n,\n                    o,\n                    r = !1,\n                    i = t.target.offsetWidth,\n                    s = t.target.offsetHeight;\n                const a = new ResizeObserver(() => {\n                  if (!r) return void (r = !0);\n                  const a = new CustomEvent(\"resize\", {\n                    bubbles: !1,\n                    cancelable: !0\n                  });\n                  n = t.target.offsetWidth, o = t.target.offsetHeight, e = n !== i || o !== s, t.target.requiresLayout && (e = !0), e && (t.resize(a), t.target.requiresLayout = !1);\n                });\n                a.observe(t.target), t.target.resizeObserver = a;\n              }\n            } else if (!t.target.resizeTrigger) {\n              const e = document.createElement(\"div\");\n              e.className = \"smart-resize-trigger-container\", e.innerHTML = '<div class=\"smart-resize-trigger-container\"><div class=\"smart-resize-trigger\"></div></div><div class=\"smart-resize-trigger-container\"><div class=\"smart-resize-trigger-shrink\"></div></div>', e.setAttribute(\"aria-hidden\", !0), window[n].EnableShadowDOM && t.target.shadowRoot ? t.target.shadowRoot.appendChild(e) : t.target.appendChild(e), t.target.resizeTrigger = e;\n\n              const o = e.childNodes[0],\n                    r = o.childNodes[0],\n                    i = e.childNodes[1],\n                    s = function () {\n                r.style.width = \"100000px\", r.style.height = \"100000px\", o.scrollLeft = 1e5, o.scrollTop = 1e5, i.scrollLeft = 1e5, i.scrollTop = 1e5;\n              };\n\n              let a,\n                  l,\n                  d,\n                  c,\n                  u = t.target.offsetWidth,\n                  p = t.target.offsetHeight;\n\n              if (0 === u || 0 === p) {\n                const e = function () {\n                  s(), t.target.removeEventListener(\"resize\", e);\n                };\n\n                t.target.addEventListener(\"resize\", e), s();\n              } else s();\n\n              t.target.resizeHandler = function () {\n                l || (l = requestAnimationFrame(function () {\n                  if (l = 0, d = t.target.offsetWidth, c = t.target.offsetHeight, a = d !== u || c !== p, t.target.requiresLayout && (a = !0), !a) return;\n                  u = d, p = c;\n                  const e = new CustomEvent(\"resize\", {\n                    bubbles: !1,\n                    cancelable: !0\n                  });\n                  t.resize(e), t.target.requiresLayout = !1;\n                })), s();\n              }, o.addEventListener(\"scroll\", t.target.resizeHandler), i.addEventListener(\"scroll\", t.target.resizeHandler);\n            }\n            t.isListening || (t.isListening = !0, t.isPressed = !1, t.isReleased = !1, t.isInBounds = !1, window.PointerEvent ? (t.$target.listen(\"pointerdown.inputEvents\" + t.id, t.pointerDown.bind(t)), t.$target.listen(\"pointerup.inputEvents\" + t.id, t.pointerUp.bind(t)), t.$target.listen(\"pointermove.inputEvents\" + t.id, t.pointerMove.bind(t)), t.$target.listen(\"pointercancel.inputEvents\" + t.id, t.pointerCancel.bind(t))) : (\"ontouchstart\" in window && (t.$target.listen(\"touchmove.inputEvents\" + t.id, t.touchMove.bind(t)), t.$target.listen(\"touchstart.inputEvents\" + t.id, t.touchStart.bind(t)), t.$target.listen(\"touchend.inputEvents\" + t.id, t.touchEnd.bind(t)), t.$target.listen(\"touchcancel.inputEvents\" + t.id, t.touchCancel.bind(t))), t.$target.listen(\"mousedown.inputEvents\" + t.id, t.mouseDown.bind(t)), t.$target.listen(\"mouseup.inputEvents\" + t.id, t.mouseUp.bind(t)), t.$target.listen(\"mousemove.inputEvents\" + t.id, t.mouseMove.bind(t)), t.$target.listen(\"mouseleave.inputEvents\" + t.id, t.mouseLeave.bind(t))), t.target._handleDocumentUp || (t.target._handleDocumentUp = t.handleDocumentUp.bind(t), t.target._handleDocumentUpId = t.id, t.$document.listen(\"mouseup.inputEvents\" + t.target._handleDocumentUpId, t.target._handleDocumentUp)));\n          }\n\n          unlisten(e) {\n            const t = this;\n            if (t.isListening = !1, window.PointerEvent ? (t.$target.unlisten(\"pointerdown.inputEvents\" + t.id), t.$target.unlisten(\"pointerup.inputEvents\" + t.id), t.$target.unlisten(\"pointermove.inputEvents\" + t.id), t.$target.unlisten(\"pointercancel.inputEvents\" + t.id)) : (\"ontouchstart\" in window && (t.$target.unlisten(\"touchstart.inputEvents\" + t.id), t.$target.unlisten(\"touchmove.inputEvents\" + t.id), t.$target.unlisten(\"touchend.inputEvents\" + t.id), t.$target.unlisten(\"touchcancel.inputEvents\" + t.id)), t.$target.unlisten(\"mousedown.inputEvents\" + t.id), t.$target.unlisten(\"mouseup.inputEvents\" + t.id), t.$target.unlisten(\"mousemove.inputEvents\" + t.id), t.$target.unlisten(\"mouseleave.inputEvents\" + t.id)), t.target._handleDocumentUp && (t.$document.unlisten(\"mouseup.inputEvents\" + t.target._handleDocumentUpId, t.target._handleDocumentUp), delete t.target._handleDocumentUp, delete t.target._handleDocumentUpId), \"resize\" === e) if (Smart.Utilities.Core.Browser.Firefox) t.target.resizeObserver && (t.target.resizeObserver.unobserve(t.target), delete t.target.resizeObserver);else if (t.target.resizeTrigger) {\n              const e = t.target.resizeTrigger,\n                    n = e.childNodes[0],\n                    o = e.childNodes[1];\n              n.removeEventListener(\"scroll\", t.target.resizeHandler), o.removeEventListener(\"scroll\", t.target.resizeHandler), t.target.resizeHandler = null, e.parentNode.removeChild(e), delete t.target.resizeTrigger;\n            }\n          }\n\n          handleDocumentUp(e) {\n            const t = this;\n            t.isPressed = !1, t.isReleased = !1, t.resetSwipe(e);\n          }\n\n          createEvent(e, t) {\n            const n = this,\n                  o = e.touches,\n                  r = e.changedTouches,\n                  i = o && o.length ? o[0] : r && r.length ? r[0] : void 0,\n                  s = new CustomEvent(t, {\n              bubbles: !0,\n              cancelable: !0,\n              composed: void 0 !== n.$target.element.getRootNode().host\n            });\n\n            if (s.originalEvent = e, i) {\n              for (let e = 0; e < n.inputEventProperties.length; e++) {\n                const t = n.inputEventProperties[e];\n                s[t] = i[t];\n              }\n\n              return s;\n            }\n\n            for (let t in e) t in s || (s[t] = e[t]);\n\n            return s;\n          }\n\n          fireTap(e) {\n            const t = this;\n\n            if (clearTimeout(this.tapHoldTimeout), !this.tapHoldFired && this.isInBounds) {\n              const n = t.createEvent(e, \"tap\");\n              t.tap(n);\n            }\n          }\n\n          initTap(e) {\n            const t = this;\n            t.isInBounds = !0, t.tapHoldFired = !1, t.tapHoldTimeout = setTimeout(function () {\n              if (t.isInBounds) {\n                t.tapHoldFired = !0;\n                const n = t.createEvent(e, \"taphold\");\n                t.taphold(n);\n              }\n            }, t.tapHoldDelay);\n          }\n\n          pointerDown(e) {\n            return this.handleDown(e);\n          }\n\n          mouseDown(e) {\n            const t = this;\n            if (!(t.isPressed || t.touchStartTime && new Date() - t.touchStartTime < 500)) return t.handleDown(e);\n          }\n\n          touchStart(e) {\n            const t = this;\n            return t.touchStartTime = new Date(), t.isTouchMoved = !0, t.handleDown(e);\n          }\n\n          mouseUp(e) {\n            const t = this;\n            if (!(t.isReleased || t.touchEndTime && new Date() - t.touchEndTime < 500)) return t.handleUp(e);\n          }\n\n          handleDown(e) {\n            const t = this;\n            t.isReleased = !1, t.isPressed = !0;\n            const n = t.createEvent(e, \"down\");\n            return (t.handlers.tap || t.handlers.taphold) && t.initTap(n), (t.handlers.swipeleft || t.handlers.swiperight || t.handlers.swipetop || t.handlers.swipebottom) && t.initSwipe(n), t.down(n);\n          }\n\n          handleUp(e) {\n            const t = this;\n            t.isReleased = !0, t.isPressed = !1;\n            const n = t.createEvent(e, \"up\"),\n                  o = t.up(n);\n            return (t.handlers.tap || t.handlers.taphold) && t.fireTap(n), t.resetSwipe(n), o;\n          }\n\n          handleMove(e) {\n            const t = this;\n            let n = t.move(e);\n            return t.isPressed && (t._maxSwipeVerticalDistance = Math.max(t._maxSwipeVerticalDistance, Math.abs(t._startY - e.pageY)), t._maxSwipeHorizontalDistance = Math.max(t._maxSwipeHorizontalDistance, Math.abs(t._startX - e.pageX)), n = t.handleSwipeEvents(e)), n;\n          }\n\n          touchEnd(e) {\n            return this.touchEndTime = new Date(), this.handleUp(e);\n          }\n\n          pointerUp(e) {\n            return this.handleUp(e);\n          }\n\n          pointerCancel(e) {\n            this.pointerUp(e);\n          }\n\n          touchCancel(e) {\n            this.touchEnd(e);\n          }\n\n          mouseLeave() {\n            this.isInBounds = !1;\n          }\n\n          mouseMove(e) {\n            if (!this.isTouchMoved) return this.handleMove(e);\n          }\n\n          pointerMove(e) {\n            return this.handleMove(e);\n          }\n\n          touchMove(e) {\n            const t = this,\n                  n = e.touches,\n                  o = e.changedTouches,\n                  r = n && n.length ? n[0] : o && o.length ? o[0] : void 0;\n\n            for (let n = 0; n < t.inputEventProperties.length; n++) {\n              const o = t.inputEventProperties[n];\n              void 0 === e[o] && (e[o] = r[o]);\n            }\n\n            return t.isTouchMoved = !0, t.handleMove(e);\n          }\n\n          handleSwipeEvents(e) {\n            const t = this;\n            let n = !0;\n            return (t.handlers.swipetop || t.handlers.swipebottom) && (n = this.handleVerticalSwipeEvents(e)), !1 === n || (t.handlers.swipeleft || t.handlers.swiperight) && (n = this.handleHorizontalSwipeEvents(e)), n;\n          }\n\n          handleVerticalSwipeEvents(e) {\n            let t, n;\n            return t = e.pageY, n = t - this._startY, this.swiped(e, n, \"vertical\");\n          }\n\n          handleHorizontalSwipeEvents(e) {\n            let t, n;\n            return t = e.pageX, n = t - this._startX, this.swiped(e, n, \"horizontal\");\n          }\n\n          swiped(e, t, n) {\n            const o = this;\n\n            if (n = n || 0, Math.abs(t) >= o.swipeMin && !o._swipeEvent && !o._swipeLocked) {\n              let r = t < 0 ? \"swipeleft\" : \"swiperight\";\n              if (\"horizontal\" === n ? o._swipeEvent = o.createEvent(e, r) : (r = t < 0 ? \"swipetop\" : \"swipebottom\", o._swipeEvent = o.createEvent(e, t < 0 ? \"swipetop\" : \"swipebottom\")), o[r] && (o[r](this._swipeEvent), Math.abs(t) <= this.swipeMax)) return e.stopImmediatePropagation(), !1;\n            }\n\n            return !0;\n          }\n\n          resetSwipe() {\n            this._swipeEvent = null, clearTimeout(this._swipeTimeout);\n          }\n\n          initSwipe(e) {\n            const t = this;\n            t._maxSwipeVerticalDistance = 0, t._maxSwipeHorizontalDistance = 0, t._startX = e.pageX, t._startY = e.pageY, t._swipeLocked = !1, t._swipeEvent = null, t._swipeTimeout = setTimeout(function () {\n              t._swipeLocked = !0;\n            }, t.swipeDelay);\n          }\n\n        }\n\n        class m {\n          get scrollWidth() {\n            const e = this;\n            return e.horizontalScrollBar ? e.horizontalScrollBar.max : -1;\n          }\n\n          set scrollWidth(e) {\n            const t = this;\n            e < 0 && (e = 0), t.horizontalScrollBar && (t.horizontalScrollBar.max = e);\n          }\n\n          get scrollHeight() {\n            const e = this;\n            return e.verticalScrollBar ? e.verticalScrollBar.max : -1;\n          }\n\n          set scrollHeight(e) {\n            const t = this;\n            e < 0 && (e = 0), t.verticalScrollBar && (t.verticalScrollBar.max = e);\n          }\n\n          get scrollLeft() {\n            const e = this;\n            return e.horizontalScrollBar ? e.horizontalScrollBar.value : -1;\n          }\n\n          set scrollLeft(e) {\n            const t = this;\n            e < 0 && (e = 0), t.horizontalScrollBar && (t.horizontalScrollBar.value = e);\n          }\n\n          get scrollTop() {\n            const e = this;\n            return e.verticalScrollBar ? e.verticalScrollBar.value : -1;\n          }\n\n          set scrollTop(e) {\n            const t = this;\n            e < 0 && (e = 0), t.verticalScrollBar && (t.verticalScrollBar.value = e);\n          }\n\n          get vScrollBar() {\n            return this.verticalScrollBar;\n          }\n\n          get hScrollBar() {\n            return this.horizontalScrollBar;\n          }\n\n          constructor(e, t, n) {\n            const o = this;\n            o.container = e, o.horizontalScrollBar = t, o.verticalScrollBar = n, o.disableSwipeScroll = !1, o.listen();\n          }\n\n          listen() {\n            const e = this,\n                  t = a.isMobile,\n                  n = e.horizontalScrollBar,\n                  o = e.verticalScrollBar;\n            let r, i, s, l, d, c, u, p;\n            e.inputEvents = new h(e.container);\n\n            const m = function (e) {\n              return {\n                amplitude: 0,\n                delta: 0,\n                initialValue: 0,\n                min: 0,\n                max: e.max,\n                previousValue: 0,\n                pointerPosition: 0,\n                targetValue: 0,\n                scrollBar: e,\n                value: 0,\n                velocity: 0\n              };\n            },\n                  f = m(n),\n                  g = m(o),\n                  w = function () {\n              const t = e.container.touchVelocityCoefficient || 50;\n              c = Date.now(), u = c - l, l = c;\n\n              const n = function (e) {\n                e.delta = e.value - e.previousValue, e.previousValue = e.value;\n                let n = t * e.delta / (1 + u);\n                e.velocity = .8 * n + .2 * e.velocity;\n              };\n\n              n(g), n(f);\n            },\n                  v = function (e) {\n              return p.value = e > p.max ? p.max : e < p.min ? p.min : e, p.scrollBar.value = p.value, e > p.max ? \"max\" : e < p.min ? \"min\" : \"value\";\n            };\n\n            function b() {\n              let t, n;\n              p.amplitude && (e.container.$.fireEvent(\"kineticScroll\"), t = Date.now() - l, n = -p.amplitude * Math.exp(-t / 500), n > 5 || n < -5 ? (v(p.targetValue + n), cancelAnimationFrame(i), i = 0, i = requestAnimationFrame(b)) : v(p.targetValue));\n            }\n\n            let C;\n            e.inputEvents.down(function (n) {\n              if (!t) return;\n              const o = n.originalEvent.target,\n                    i = o && o.closest ? o.closest(\"smart-scroll-bar\") : void 0;\n              if (i === e.horizontalScrollBar || i === e.verticalScrollBar) return;\n              s = !0, r = !1;\n\n              const a = function (e, t) {\n                e.amplitude = 0, e.pointerPosition = t, e.previousValue = e.value, e.value = e.scrollBar.value, e.initialValue = e.value, e.max = e.scrollBar.max;\n              };\n\n              a(g, n.clientY), a(f, n.clientX), l = Date.now(), clearInterval(d), d = setInterval(w, 500);\n            }), e.inputEvents.up(function () {\n              if (!s) return !0;\n              if (clearInterval(d), e.disableSwipeScroll) return void (s = !1);\n\n              const t = function (e) {\n                p = e, e.amplitude = .8 * e.velocity, e.targetValue = Math.round(e.value + e.amplitude), l = Date.now(), cancelAnimationFrame(i), i = requestAnimationFrame(b), e.velocity = 0;\n              };\n\n              g.velocity > 10 || g.velocity < -10 ? t(g) : (f.velocity > 10 || f.velocity < -10) && t(f), s = !1;\n            }), e.inputEvents.move(function (t) {\n              if (!s) return !0;\n              if (e.disableSwipeScroll) return;\n              if (r && (t.originalEvent.preventDefault(), t.originalEvent.stopPropagation()), f.visible = e.scrollWidth > 0, g.visible = e.scrollHeight > 0, !s || !f.visible && !g.visible) return;\n              const n = e.container.touchScrollRatio,\n                    o = e.container;\n              let i, a;\n              n && (\"number\" == typeof n ? (i = -n, a = -n) : \"function\" == typeof n && (i = n(g.max, o.offsetHeight), a = n(f.max, o.offsetWidth))), g.ratio = i || -g.max / o.offsetHeight, g.delta = (t.clientY - g.pointerPosition) * g.ratio, f.ratio = a || -f.max / o.offsetWidth, f.delta = (t.clientX - f.pointerPosition) * f.ratio;\n              let l = \"value\";\n\n              const d = function (t, n, o) {\n                return t.delta > 5 || t.delta < -5 ? (p = t, l = t.initialValue + t.delta > p.max ? \"max\" : t.initialValue + t.delta < p.min ? \"min\" : \"value\", \"min\" === l && 0 === t.initialValue || \"max\" === l && t.initialValue === t.max || !t.visible || (e.container.$.fireEvent(\"kineticScroll\"), v(t.initialValue + t.delta), w(), o.originalEvent.preventDefault(), o.originalEvent.stopPropagation(), r = !0, !1)) : null;\n              };\n\n              let c = d(g, t.clientY, t);\n              if (null !== c) return c;\n              {\n                let e = d(f, t.clientX, t);\n                if (null !== e) return e;\n              }\n            }), e.scrollTo = function (t, n) {\n              const o = !1 === n ? f : g;\n              let r = !1;\n              l || (l = Date.now()), C || (C = Date.now()), Math.abs(Date.now() - C) > 375 ? l = Date.now() : r = !0, C = Date.now(), o.value = o.scrollBar.value, o.delta = t - o.value, o.max = o.scrollBar.max, t <= o.min && (t = o.min), t >= o.max && (t = o.max), o.targetValue = t;\n              const s = t;\n              let a = o.value;\n              o.velocity = 100 * o.delta / (1 + o.max), o.from = a;\n\n              const d = function (e) {\n                return o.value = e > o.max ? o.max : e < o.min ? o.min : e, o.scrollBar.value = o.value, e > o.max ? \"max\" : e < o.min ? \"min\" : \"value\";\n              },\n                    c = function () {\n                let n,\n                    u = Date.now() - C,\n                    p = Math.min(1e3, Date.now() - l),\n                    h = o.velocity * Math.exp(p / 175);\n                if (r) (h < 0 && o.value <= t || h > 0 && o.value >= t) && (h = 0), (o.value + h <= o.min || o.value + h >= o.max) && (h = 0), h > .5 || h < -.5 ? (d(o.value + h), cancelAnimationFrame(i), i = 0, i = requestAnimationFrame(c)) : d(o.targetValue);else {\n                  if (u >= 175) return cancelAnimationFrame(i), e.container.$.fireEvent(\"kineticScroll\"), void (i = 0);\n                  n = y.Animation.Easings.easeInSine(u, a, s - a, 175), d(n), cancelAnimationFrame(i), i = 0, i = requestAnimationFrame(c);\n                }\n              };\n\n              cancelAnimationFrame(i), i = requestAnimationFrame(c);\n            }, e.inputEvents.listen();\n          }\n\n          unlisten() {\n            const e = this;\n            e.inputEvents && e.inputEvents.unlisten(), delete e.inputEvents;\n          }\n\n        }\n\n        class f {\n          constructor(e) {\n            this.events = {}, this.handlers = {}, this.element = e;\n          }\n\n          hasClass(e) {\n            const t = this,\n                  n = e.split(\" \");\n\n            for (let e = 0; e < n.length; e++) if (!t.element.classList.contains(n[e])) return !1;\n\n            return !0;\n          }\n\n          addClass(e) {\n            const t = this;\n            if (t.hasClass(e)) return;\n            const n = e.split(\" \");\n\n            for (let e = 0; e < n.length; e++) t.element.classList.add(n[e]);\n\n            t.isNativeElement || d.observeElement(t.element);\n          }\n\n          removeClass(e) {\n            const t = this;\n            if (0 === arguments.length) return void t.element.removeAttribute(\"class\");\n            const n = e.split(\" \");\n\n            for (let e = 0; e < n.length; e++) t.element.classList.remove(n[e]);\n\n            \"\" === t.element.className && t.element.removeAttribute(\"class\"), t.isNativeElement || d.observeElement(t.element);\n          }\n\n          get isCustomElement() {\n            const e = this;\n            return !!e.element.tagName.startsWith(n) || e.element instanceof window[n].BaseElement == 1 || \"DIV\" !== e.element.tagName && \"SPAN\" !== e.element.tagName && \"BUTTON\" !== e.element.tagName && \"INPUT\" !== e.element.tagName && \"UL\" !== e.element.tagName && \"LI\" !== e.element.tagName && document.createElement(e.element.nodeName) instanceof window[n].BaseElement == 1;\n          }\n\n          get isNativeElement() {\n            return !this.isCustomElement;\n          }\n\n          dispatch(e) {\n            const t = this,\n                  n = t.events[e.type];\n            let o = !1;\n            if (n.length > 1) for (let e = 0; e < n.length; e++) {\n              const t = n[e];\n\n              if (t.namespace && t.namespace.indexOf(\"_\") >= 0) {\n                o = !0;\n                break;\n              }\n            }\n            o && n.sort(function (e, t) {\n              let n = e.namespace,\n                  o = t.namespace;\n              return n = -1 === n.indexOf(\"_\") ? 0 : parseInt(n.substring(n.indexOf(\"_\") + 1)), o = -1 === o.indexOf(\"_\") ? 0 : parseInt(o.substring(o.indexOf(\"_\") + 1)), n < o ? -1 : n > o ? 1 : 0;\n            });\n\n            for (let o = 0; o < n.length; o++) {\n              const r = n[o];\n              if (e.namespace = r.namespace, e.context = r.context, e.defaultPrevented) break;\n              const i = r.handler.apply(t.element, [e]);\n\n              if (void 0 !== i && (e.result = i, !1 === i)) {\n                e.preventDefault(), e.stopPropagation();\n                break;\n              }\n            }\n\n            return e.result;\n          }\n\n          fireEvent(e, t, n) {\n            const o = this;\n            n || (n = {\n              bubbles: !0,\n              cancelable: !0,\n              composed: null !== o.element.getRootNode().host\n            }), n.detail = t || {};\n            const r = new CustomEvent(e, n);\n            return r.originalStopPropagation = r.stopPropagation, r.stopPropagation = function () {\n              return r.isPropagationStopped = !0, r.originalStopPropagation();\n            }, o.dispatchEvent(r), r;\n          }\n\n          get isPassiveSupported() {\n            const e = this;\n            if (void 0 !== e.supportsPassive) return e.supportsPassive;\n            e.supportsPassive = !1;\n\n            try {\n              let t = Object.defineProperty({}, \"passive\", {\n                get: function () {\n                  e.supportsPassive = !0;\n                }\n              });\n              window.addEventListener(\"testPassive\", null, t), window.removeEventListener(\"testPassive\", null, t);\n            } catch (e) {}\n\n            return e.supportsPassive;\n          }\n\n          dispatchEvent(e) {\n            const t = this,\n                  n = e.type,\n                  o = t.element.context,\n                  r = n.substring(0, 1).toUpperCase() + n.substring(1);\n            t.element.context = document, t.element[\"on\" + r] ? t.element[\"on\" + r](e) : t.element[\"on\" + n.toLowerCase()] ? t.element[\"on\" + n.toLowerCase()](e) : t.element.dispatchEvent(e), t.element.context = o;\n          }\n\n          listen(e, t) {\n            const n = this,\n                  o = e.split(\".\"),\n                  r = o.slice(1).join(\".\"),\n                  i = o[0];\n            n.events[i] || (n.events[i] = []);\n            const s = {\n              type: i,\n              handler: t,\n              context: n.element,\n              namespace: r\n            };\n            p.indexOf(i) >= 0 && (n.inputEvents || (n.inputEvents = new h(n.element)), n.inputEvents[i](function (e) {\n              n.dispatchEvent(e);\n            }), n.inputEvents.boundEventTypes.push(i), n.inputEvents.listen(i)), 0 === n.events[i].length && (n.handlers[i] = n.dispatch.bind(n), \"wheel\" === i ? n.element.addEventListener(\"wheel\", n.handlers[i], !!n.isPassiveSupported && {\n              passive: !1\n            }) : \"touchmove\" === i || \"touchstart\" === i || \"touchend\" === i ? n.element.addEventListener(i, n.handlers[i], !!n.isPassiveSupported && {\n              passive: !1\n            }) : n.element.addEventListener(i, n.handlers[i], !1)), n.events[i].push(s);\n          }\n\n          unlisten(e) {\n            const t = this,\n                  n = e.split(\".\"),\n                  o = n.slice(1).join(\".\"),\n                  r = n[0];\n            let i = t.events[r];\n\n            if (t.inputEvents && t.inputEvents.boundEventTypes.indexOf(r) >= 0 && (t.inputEvents.boundEventTypes.splice(t.inputEvents.boundEventTypes.indexOf(r), 1), 0 === t.inputEvents.boundEventTypes.length && t.inputEvents.unlisten(r)), i) {\n              for (let e = 0; e < i.length; e++) {\n                if (\"\" !== o) {\n                  let e = i.findIndex(e => e.namespace === o);\n                  i.splice(e, 1);\n                  break;\n                }\n\n                i = [];\n              }\n\n              0 === i.length && (t.element.removeEventListener(r, t.handlers[r]), t.events[r] = [], delete t.handlers[r]);\n            }\n          }\n\n          getAttributeValue(e, t) {\n            const n = this,\n                  o = n.element.getAttribute(e);\n            if (n.isNativeElement) return n.deserialize(o, t);\n            const r = n.element.propertyByAttributeName[e];\n            return void 0 === r.deserialize ? n.deserialize(o, t, r.nullable) : n.element[r.deserialize](o);\n          }\n\n          setAttributeValue(e, t, n) {\n            const o = this;\n            let r,\n                i = !1;\n\n            if (o.isNativeElement) {\n              if (r = o.serialize(t, n), \"boolean\" === n && [\"checked\", \"selected\", \"async\", \"autofocus\", \"autoplay\", \"controls\", \"defer\", \"disabled\", \"hidden\", \"ismap\", \"loop\", \"multiple\", \"open\", \"readonly\", \"required\", \"scoped\"].indexOf(e) >= 0) return void (t ? o.element.setAttribute(e, \"\") : o.element.removeAttribute(e));\n            } else {\n              const s = o.element.propertyByAttributeName[e];\n              i = !s || s.nullable, r = s && s.serialize ? o.element[s.serialize](t) : o.serialize(t, n, i);\n            }\n\n            \"array\" !== n && \"object\" !== n || \"[]\" !== r && \"{}\" !== r ? void 0 === r ? (o.element.removeAttribute(e), o.element.shadowRoot && o.element.$.root && o.element.$.root.removeAttribute(e)) : (o.element.setAttribute(e, r), o.element.shadowRoot && o.element.$.root && o.element.$.root.setAttribute(e, r)) : o.element.removeAttribute(e);\n          }\n\n          serialize(e, t, n) {\n            if (void 0 === t && (t = y.Types.getType(e)), void 0 !== e && (n || null !== e)) {\n              if (n && null === e) return \"null\";\n              if (\"string\" === t) return e;\n\n              if (\"boolean\" === t || \"bool\" === t) {\n                if (!0 === e || \"true\" === e || 1 === e || \"1\" === e) return \"\";\n                if (!1 === e || \"false\" === e || 0 === e || \"0\" === e) return;\n              }\n\n              return \"array\" === t ? JSON.stringify(e) : [\"string\", \"number\", \"int\", \"integer\", \"float\", \"date\", \"any\", \"function\"].indexOf(t) >= 0 ? e.toString() : \"object\" === t ? JSON.stringify(e) : void 0;\n            }\n          }\n\n          deserialize(e, t, n) {\n            const o = \"null\" === e;\n\n            if (void 0 !== e && (!o || n)) {\n              if (o && n) return null;\n              if (\"boolean\" === t || \"bool\" === t) return null !== e;\n              if (\"number\" === t || \"float\" === t) return \"NaN\" === e ? NaN : \"Infinity\" === e ? 1 / 0 : \"-Infinity\" === e ? -1 / 0 : parseFloat(e);\n              if (\"int\" === t || \"integer\" === t) return \"NaN\" === e ? NaN : \"Infinity\" === e ? 1 / 0 : \"-Infinity\" === e ? -1 / 0 : parseInt(e);\n              if (\"string\" === t) return e;\n              if (\"any\" === t) return e;\n              if (\"date\" === t) return new Date(e);\n\n              if (\"function\" === t) {\n                if (\"function\" == typeof window[e]) return window[e];\n              } else if (\"array\" === t || \"object\" === t) try {\n                const t = JSON.parse(e);\n                if (t) return t;\n              } catch (n) {\n                if (window[e] && \"object\" == typeof window[e]) return window[e];\n\n                if (\"array\" === t && e.indexOf(\"[\") >= 0) {\n                  if (e.indexOf(\"{\") >= 0) {\n                    let t = e.replace(/{/gi, \"\").replace(\"[\", \"\").replace(\"]\", \"\").replace(/'/gi, \"\").replace(/\"/gi, \"\").trim();\n                    t = t.split(\"},\");\n\n                    for (let e = 0; e < t.length; e++) {\n                      let n = {},\n                          o = t[e].trim().split(\",\");\n\n                      for (let e = 0; e < o.length; e++) {\n                        const t = o[e].split(\":\")[0].trim(),\n                              r = o[e].split(\":\")[1].trim();\n                        n[t] = r;\n                      }\n\n                      t[e] = n;\n                    }\n\n                    return t;\n                  }\n\n                  return e.replace(\"[\", \"\").replace(\"]\", \"\").replace(/'/gi, \"\").replace(/\"/gi, \"\").trim().split(\",\");\n                }\n              }\n            }\n          }\n\n        }\n\n        class g {\n          static get Ripple() {\n            return i;\n          }\n\n          static get Easings() {\n            return s;\n          }\n\n        }\n\n        class y {\n          static get Types() {\n            return r;\n          }\n\n          static get Core() {\n            return a;\n          }\n\n          static get Animation() {\n            return g;\n          }\n\n          static get Scroll() {\n            return m;\n          }\n\n          static get InputEvents() {\n            return h;\n          }\n\n          static Extend(e) {\n            return new f(e);\n          }\n\n          static Assign(e, t) {\n            if (e.indexOf(\".\") >= 0) {\n              const n = e.split(\".\");\n              return y[n[0]] || (y[n[0]] = {}), void (y[n[0]][n[1]] = t);\n            }\n\n            y[e] = t;\n          }\n\n        }\n\n        const w = y.Extend(document);\n        let v = null;\n        document.addEventListener(\"click\", () => {\n          d.start(), v && clearTimeout(v), v = setTimeout(() => {\n            d.stop();\n          }, 1e4);\n        }), document.addEventListener(\"mouseenter\", () => {\n          d.start();\n        }), document.addEventListener(\"mouseleave\", () => {\n          d.stop();\n        });\n        let b = /*#__PURE__*/(() => {\n          class b {}\n\n          b.cache = {};\n          return b;\n        })();\n\n        class C extends HTMLElement {\n          static get properties() {\n            return {\n              animation: {\n                value: \"advanced\",\n                type: \"string\",\n                allowedValues: [\"none\", \"simple\", \"advanced\"]\n              },\n              unfocusable: {\n                value: !1,\n                type: \"boolean\"\n              },\n              disabled: {\n                value: !1,\n                type: \"boolean\"\n              },\n              dataContext: {\n                value: null,\n                reflectToAttribute: !1,\n                type: \"any\"\n              },\n              debugMode: {\n                value: !0,\n                type: \"boolean\",\n                reflectToAttribute: !1\n              },\n              locale: {\n                value: \"en\",\n                type: \"string\",\n                reflectToAttribute: !1\n              },\n              localizeFormatFunction: {\n                value: void 0,\n                type: \"function\",\n                reflectToAttribute: !1\n              },\n              messages: {\n                value: {\n                  en: {\n                    propertyUnknownName: \"Invalid property name: '{{name}}'!\",\n                    propertyUnknownType: \"'{{name}}' property is with undefined 'type' member!\",\n                    propertyInvalidValue: \"Invalid '{{name}}' property value! Actual value: '{{actualValue}}', Expected value: '{{value}}'!\",\n                    propertyInvalidValueType: \"Invalid '{{name}}' property value type! Actual type: '{{actualType}}', Expected type: '{{type}}'!\",\n                    methodInvalidValueType: \"Invalid '{{name}}' method argument value type! Actual type: '{{actualType}}', Expected type: '{{type}}' for argument with index: '{{argumentIndex}}'!\",\n                    methodInvalidArgumentsCount: \"Invalid '{{name}}' method arguments count! Actual arguments count: '{{actualArgumentsCount}}', Expected at least: '{{argumentsCount}}' argument(s)!\",\n                    methodInvalidReturnType: \"Invalid '{{name}}' method return type! Actual type: '{{actualType}}', Expected type: '{{type}}'!\",\n                    elementNotInDOM: \"Element does not exist in DOM! Please, add the element to the DOM, before invoking a method.\",\n                    moduleUndefined: \"Module is undefined.\",\n                    missingReference: \"{{elementType}}: Missing reference to '{{files}}'.\",\n                    htmlTemplateNotSuported: \"{{elementType}}: Web Browser doesn't support HTMLTemplate elements.\",\n                    invalidTemplate: \"{{elementType}}: '{{property}}' property accepts a string that must match the id of an HTMLTemplate element from the DOM.\"\n                  }\n                },\n                reflectToAttribute: !1,\n                inherit: !0,\n                type: \"object\"\n              },\n              props: {\n                value: null,\n                reflectToAttribute: !1,\n                isHierarchicalProperty: !0,\n                type: \"any\"\n              },\n              readonly: {\n                value: !1,\n                type: \"boolean\"\n              },\n              renderMode: {\n                value: \"auto\",\n                type: \"string\",\n                reflectToAttribute: !1,\n                allowedValues: [\"auto\", \"manual\"]\n              },\n              rightToLeft: {\n                value: !1,\n                type: \"boolean\"\n              },\n              rethrowError: {\n                value: !0,\n                type: \"boolean\",\n                reflectToAttribute: !1\n              },\n              theme: {\n                value: window[n].Theme,\n                type: \"string\"\n              },\n              visibility: {\n                value: \"visible\",\n                allowedValues: [\"visible\", \"collapsed\", \"hidden\"],\n                type: \"string\"\n              },\n              wait: {\n                value: !1,\n                type: \"boolean\"\n              }\n            };\n          }\n\n          getBindings(e, t) {\n            const n = this;\n\n            let o = 0,\n                r = {},\n                i = (e => {\n              if (e instanceof HTMLElement) return n.parseAttributes(e);\n              {\n                let t = n.parseProperty(e.data ? e.data.trim() : null, \"textContent\", e);\n                if (t) return n && e.parentNode === n.$.content && (t.value = \"\" !== n.$.html ? n.$.html : void 0, n.innerHTML = \"\"), {\n                  textContent: t\n                };\n              }\n            })(e);\n\n            i && (r.data = i), t || (r.mapping = [], t = r), e.getAttribute && (r.nodeId = e.getAttribute(\"smart-id\"), t && i && (t.mapping[r.nodeId] = i)), r.node = e, e.firstChild && (r.children = {});\n\n            for (let i = e.firstChild; i; i = i.nextSibling) r.children[o++] = n.getBindings(i, t);\n\n            return r;\n          }\n\n          _addRemovePropertyBinding(e, t, n, o, r) {\n            if (!e || !t || !n) return;\n            const i = this,\n                  s = i.bindings,\n                  a = n.getAttribute(\"smart-id\"),\n                  l = e.indexOf(\"{{\") >= 0;\n            let d = !1;\n            (e = e.replace(\"{{\", \"\").replace(\"}}\", \"\").replace(\"[[\", \"\").replace(\"]]\", \"\")).indexOf(\"!\") >= 0 && (e = e.replace(\"!\", \"\"), d = !0);\n            const c = i._properties[e],\n                  u = {\n              name: e,\n              reflectToAttribute: c.reflectToAttribute,\n              twoWay: l,\n              type: c.type,\n              not: d\n            };\n\n            if (r && !o) {\n              const n = {},\n                    o = {\n                name: e,\n                targetPropertyName: t,\n                reflectToAttribute: c.reflectToAttribute,\n                twoWay: l,\n                type: c.type,\n                not: d\n              };\n              n[e] = o, s.mapping[a] = n;\n            }\n\n            const p = function (e) {\n              for (let r in e) {\n                const s = e[r];\n\n                if (s.nodeId === a) {\n                  s.data || (s.data = {}), o ? (s.data[t] = null, delete s.data[t]) : s.data[t] = u;\n                  break;\n                }\n\n                if (s.children) p(s.children);else if (s.node && s.node.children && s.node === n.parentElement) {\n                  const e = s.node;\n                  if (!e.firstChild) continue;\n                  s.children = {};\n                  let t = 0;\n\n                  for (let n = e.firstChild; n; n = n.nextSibling) s.children[t++] = i.getBindings(n);\n\n                  p(s.children);\n                }\n              }\n            };\n\n            p(s.children), o ? delete i.boundProperties[e] : i.boundProperties[e] = !0, i.updateBoundNodes(e);\n          }\n\n          addPropertyBinding(e, t, n, o) {\n            this._addRemovePropertyBinding(e, t, n, !1, o);\n          }\n\n          removePropertyBinding(e, t, n, o) {\n            this._addRemovePropertyBinding(e, t, n, !0, o);\n          }\n\n          parseAttributes(e) {\n            const t = this;\n            let n;\n\n            for (let o = 0; o < e.attributes.length; o++) {\n              const r = e.attributes[o],\n                    i = r.name,\n                    s = r.value;\n              b.cache[\"toCamelCase\" + i] || (b.cache[\"toCamelCase\" + i] = y.Core.toCamelCase(i));\n              const a = b.cache[\"toCamelCase\" + i];\n\n              if (i.indexOf(\"(\") >= 0) {\n                let o = i.substring(1, i.length - 1);\n\n                if (t && !t.dataContext) {\n                  t.templateListeners[e.getAttribute(\"smart-id\") + \".\" + o] = s, e.removeAttribute(i);\n                  continue;\n                }\n\n                {\n                  n || (n = {});\n                  const e = s.substring(0, s.indexOf(\"(\"));\n                  n[a] = {\n                    isEvent: !0,\n                    name: o,\n                    value: e\n                  };\n                  continue;\n                }\n              }\n\n              let l = t.parseProperty(s, i, e);\n              l && (n || (n = {}), n[a] = l);\n            }\n\n            return n;\n          }\n\n          parseProperty(e, t) {\n            if (!e || !e.length) return;\n            const n = this;\n            let o,\n                r = e.length,\n                i = 0,\n                s = 0,\n                a = 0,\n                l = !0;\n\n            for (; s < r;) {\n              i = e.indexOf(\"{{\", s);\n              let t = e.indexOf(\"[[\", s),\n                  n = \"}}\";\n              if (t >= 0 && (i < 0 || t < i) && (i = t, l = !1, n = \"]]\"), a = i < 0 ? -1 : e.indexOf(n, i + 2), a < 0) return;\n              o = o || {};\n              let r = e.slice(i + 2, a).trim();\n              o.name = r, s = a + 2;\n            }\n\n            const d = o.name,\n                  c = n ? n._properties[d] : null;\n            return o.twoWay = l, o.ready = !1, n && (d.indexOf(\"::\") >= 0 ? n.boundProperties[d.substring(0, d.indexOf(\"::\"))] = !0 : n.boundProperties[d] = !0), c ? (o.type = c.type, o.reflectToAttribute = c.reflectToAttribute) : ([\"checked\", \"selected\", \"async\", \"autofocus\", \"autoplay\", \"controls\", \"defer\", \"disabled\", \"hidden\", \"ismap\", \"loop\", \"multiple\", \"open\", \"readonly\", \"required\", \"scoped\"].indexOf(t) >= 0 ? o.type = \"boolean\" : o.type = \"string\", o.reflectToAttribute = !0), o;\n          }\n\n          updateTextNodes() {\n            const e = this;\n            e.updateTextNode(e.shadowRoot || e, e.bindings, e);\n          }\n\n          updateTextNode(e, t, n) {\n            const o = this;\n            if (!t) return;\n            let r = 0;\n\n            for (let i = e.firstChild; i && t.children; i = i.nextSibling) o.updateTextNode(i, t.children[r++], n);\n\n            if (t && t.data) for (let e in t.data) {\n              const o = t.data[e],\n                    r = o.name;\n              \"textContent\" === e && o.twoWay && !o.updating && void 0 !== o.value && (n[r] = o.value);\n            }\n          }\n\n          updateBoundProperty(e, t) {\n            if (t.updating) return;\n            const n = this;\n            t.updating = !0, n[e] = t.value, t.updating = !1;\n          }\n\n          updateBoundNodes(e) {\n            const t = this;\n            if (t.updateBoundNode(t.shadowRoot || t, t.bindings, t, e), t.detachedChildren.length > 0) for (let n = 0; n < t.detachedChildren.length; n++) {\n              const o = t.detachedChildren[n],\n                    r = o.getAttribute(\"smart-id\"),\n                    i = function (e) {\n                if (e.nodeId === r) return e;\n\n                for (let t in e.children) {\n                  const n = e.children[t];\n                  if ((n.getAttribute ? n.getAttribute(\"smart-id\") : \"\") === r) return e;\n\n                  if (n.children) {\n                    const e = i(n);\n                    if (e) return e;\n                  }\n                }\n\n                return null;\n              },\n                    s = i(t.bindings);\n\n              if (s) t.updateBoundNode(o, s, t, e, !0);else if (o.getAttribute && t.bindings.mapping) {\n                const n = t,\n                      o = t.bindings;\n                if (o) for (let r in o.mapping) {\n                  const i = n.querySelector('[smart-id=\"' + r + '\"]');\n\n                  if (i) {\n                    const s = o.mapping[r];\n                    t.updateBoundData(i, s, n, e);\n                  }\n                }\n              }\n            }\n          }\n\n          updateBoundMappedNodes() {\n            const e = this,\n                  t = e.bindings,\n                  n = e;\n            if (t.mapping) for (let o in t.mapping) {\n              let r = n.querySelector('[smart-id=\"' + o + '\"]');\n\n              if (n.shadowRoot && (r = n.querySelector('[id=\"' + o + '\"]'), r || (r = n.shadowRoot.querySelector('[id=\"' + o + '\"]') || n.shadowRoot.querySelector('[smart-id=\"' + o + '\"]'))), r) {\n                const i = t.mapping[o];\n                e.updateBoundData(r, i, n);\n              } else if (n.getAttribute(\"aria-controls\")) {\n                let i = document.getElementById(n.getAttribute(\"aria-controls\"));\n\n                if (!i && n.shadowRoot && (i = n.shadowRoot.getElementById(n.getAttribute(\"aria-controls\"))), r = i.querySelector('[smart-id=\"' + o + '\"]'), r) {\n                  const i = t.mapping[o];\n                  e.updateBoundData(r, i, n);\n                }\n              }\n            }\n          }\n\n          updateBoundNode(e, t, n, o, r) {\n            const i = this;\n            if (!t) return;\n            let s = 0;\n\n            if (r) {\n              if (r && !t.data) for (let a = e.firstChild; a && t.children; a = a.nextSibling) if (a.getAttribute) {\n                const e = a.getAttribute(\"smart-id\"),\n                      r = function () {\n                  for (let n in t.children) if (t.children[n].nodeId === e) return t.children[n];\n                }();\n\n                i.updateBoundNode(a, r, n, o), s++;\n              } else i.updateBoundNode(a, t.children[s++], n, o, r);\n            } else for (let r = e.firstChild; r && t.children; r = r.nextSibling) if (r.getAttribute) {\n              const e = r.getAttribute(\"smart-id\"),\n                    a = function () {\n                for (let n in t.children) if (t.children[n].nodeId === e) return t.children[n];\n              }();\n\n              i.updateBoundNode(r, a, n, o), s++;\n            } else i.updateBoundNode(r, t.children[s++], n, o);\n\n            if (!t || !t.data) return;\n            const a = t.data;\n            i.updateBoundData(e, a, n, o);\n          }\n\n          updateBoundData(e, t, n, o) {\n            const r = this;\n\n            for (let i in t) {\n              const s = t[i];\n              let a = s.name;\n\n              if (!s.updating && (a.indexOf(\"::\") >= 0 && (a = a.substring(0, a.indexOf(\"::\"))), void 0 === o || o === a)) {\n                if (a.indexOf(\"(\") >= 0) {\n                  let e = a.substring(a.indexOf(\"(\"));\n                  const t = a.substring(0, a.indexOf(\"(\"));\n\n                  if (e = e.substring(1, e.length - 1), e = e.replace(/ /gi, \"\"), e = e.split(\",\"), e.length > 0 && \"\" !== e[0]) {\n                    let o = [];\n\n                    for (let t = 0; t < e.length; t++) o.push(n[e[t]]);\n\n                    s.value = n[t].apply(n, o);\n                  } else s.value = n[t]();\n\n                  s.type = typeof s.value;\n                } else s.value = n[a];\n\n                if (\"innerHTML\" === a) {\n                  if (e[i].toString().trim() !== n[a].toString().trim()) {\n                    if (window.smartBlazor && e[i].indexOf(\"\\x3c!--\") >= 0) {\n                      (s.ready || n._properties[a].defaultValue !== s.value) && (e[i] = s.value.toString());\n                      continue;\n                    }\n\n                    (s.ready || n._properties[a].defaultValue !== s.value) && (e[i] = s.value.toString().trim());\n                  }\n                } else s.not ? (e[i] = !s.value, s.targetPropertyName && (e[s.targetPropertyName] = !s.value)) : (e[i] = s.value, s.targetPropertyName && (e[s.targetPropertyName] = s.value));\n\n                if (e.$ && e.$.isNativeElement) {\n                  b.cache[\"toDash\" + i] || (b.cache[\"toDash\" + i] = y.Core.toDash(i));\n                  const t = b.cache[\"toDash\" + i],\n                        n = e.$.getAttributeValue(t, s.type);\n                  !s.reflectToAttribute || n === s.value && s.ready || e.$.setAttributeValue(t, s.value, s.type), s.reflectToAttribute || e.$.setAttributeValue(t, null, s.type);\n                }\n\n                if (!s.ready) {\n                  if (e.$ && e.$.isCustomElement) {\n                    b.cache[\"toDash\" + i] || (b.cache[\"toDash\" + i] = y.Core.toDash(i));\n                    const t = b.cache[\"toDash\" + i];\n                    e._properties || (e._beforeCreatedProperties = e._properties = e.propertyByAttributeName = []), e._properties[i] || (e._properties[i] = {\n                      attributeName: t\n                    }, e._beforeCreatedProperties && (e._beforeCreatedProperties[i] = e._properties[i]), e.propertyByAttributeName[t] = e._properties[i]);\n                    const n = e._properties[i];\n                    n.isUpdating = !0, s.reflectToAttribute && (s.not ? e.$.setAttributeValue(n.attributeName, !s.value, s.type) : e.$.setAttributeValue(n.attributeName, s.value, s.type)), s.reflectToAttribute || e.$.setAttributeValue(n.attributeName, null, s.type), n.isUpdating = !1;\n                  }\n\n                  if (s.twoWay) {\n                    const t = function (t) {\n                      if (s.value = t, e.$ && e.$.isNativeElement) {\n                        b.cache[\"toDash\" + i] || (b.cache[\"toDash\" + i] = y.Core.toDash(i));\n                        const t = b.cache[\"toDash\" + i],\n                              n = e.$.getAttributeValue(t, s.type);\n                        s.reflectToAttribute && n !== s.value && e.$.setAttributeValue(t, s.value, s.type), s.reflectToAttribute || e.$.setAttributeValue(t, null, s.type);\n                      }\n                    };\n\n                    if (s.name.indexOf(\"::\") >= 0) {\n                      const n = s.name.indexOf(\"::\"),\n                            o = s.name.substring(n + 2);\n                      r[\"$\" + e.getAttribute(\"smart-id\")].listen(o, function () {\n                        t(e[i]);\n                        const n = s.name.substring(0, s.name.indexOf(\"::\"));\n                        r.updateBoundProperty(n, s);\n                      });\n                    }\n\n                    if (e.$ && e.$.isCustomElement) {\n                      e._properties[i] && (e._properties[i].notify = !0), b.cache[\"toDash\" + i] || (b.cache[\"toDash\" + i] = y.Core.toDash(i));\n                      const n = b.cache[\"toDash\" + i];\n                      r[\"$\" + e.getAttribute(\"smart-id\")].listen(n + \"-changed\", function (e) {\n                        let n = e.detail;\n                        t(n.value);\n                        const o = r.context;\n                        e.context !== document && (r.context = r), r.updateBoundProperty(s.name, s), r.context = o;\n                      });\n                    }\n                  }\n                }\n\n                s.ready = !0;\n              }\n            }\n          }\n\n          static clearCache() {\n            this.cache = {};\n          }\n\n          addMessages(e, t) {\n            Object.assign(this.messages[e], t);\n          }\n\n          localize(e, t) {\n            const n = this;\n            if (!n.messages || !n.messages[n.locale]) return;\n            let o = n.messages[n.locale][e];\n            if (\"\" === o) return \"\";\n\n            if (!o) {\n              const t = n.messages.en;\n\n              if (t) {\n                const n = t[e];\n                return n || e;\n              }\n            }\n\n            const r = o;\n\n            for (let e in t) {\n              let n = t[e];\n              o = o.replace(new RegExp(\"{{\" + e + \"}}\", \"g\"), n);\n            }\n\n            return n.localizeFormatFunction && n.localizeFormatFunction(r, o, t), o;\n          }\n\n          static get requires() {\n            return {};\n          }\n\n          static get listeners() {\n            return {\n              \"theme-changed\": function (e) {\n                this.theme = e.detail.newValue;\n              }\n            };\n          }\n\n          static get methods() {\n            return {};\n          }\n\n          get classNamesMap() {\n            return {\n              animation: \"smart-animate\",\n              rippleAnimation: \"smart-ripple\"\n            };\n          }\n\n          get hasAnimation() {\n            return \"none\" !== this.animation;\n          }\n\n          get hasRippleAnimation() {\n            return \"none\" !== this.animation && \"advanced\" === this.animation;\n          }\n\n          static get modules() {\n            return window[n].Modules;\n          }\n\n          get properties() {\n            const e = this;\n            return e._properties || (e._properties = []), e._properties;\n          }\n\n          get parents() {\n            const e = this;\n            let t = [],\n                o = e.parentNode;\n\n            for (; o && 9 !== o.nodeType;) o instanceof HTMLElement == 1 && t.push(o), o = o.parentNode;\n\n            const r = e.getRootNode();\n\n            if (r.host) {\n              const e = e => {\n                let t = [e],\n                    n = e.parentNode;\n\n                for (; n && 9 !== n.nodeType;) n instanceof HTMLElement == 1 && t.push(n), n = n.parentNode;\n\n                return t;\n              };\n\n              t = t.concat(e(r.host));\n            }\n\n            return window[n].EnableShadowDOM && e.isInShadowDOM && e.shadowParent && (t = t.concat(e.shadowParent.parents)), t;\n          }\n\n          log(e) {\n            this._logger(\"log\", e);\n          }\n\n          warn(e) {\n            this._logger(\"warn\", e);\n          }\n\n          error(e) {\n            this._logger(\"error\", e);\n          }\n\n          _logger(e, t) {\n            if (this.debugMode) {\n              const n = t instanceof Error ? t.message : t.toString();\n              console[e](n);\n            }\n\n            if (this.rethrowError && \"error\" === e) throw t;\n          }\n\n          get focused() {\n            return this.contains(document.activeElement);\n          }\n\n          template() {\n            return \"<div></div>\";\n          }\n\n          registered() {\n            const e = this;\n            e.onRegistered && e.onRegistered();\n          }\n\n          created() {\n            const e = this;\n            e.isReady = !1, e._initElement(e), e._setModuleState(\"created\"), e.onCreated && e.onCreated();\n          }\n\n          completed() {\n            const e = this;\n            e.isCompleted = !0, e._onCompleted && e._onCompleted(), e.onCompleted && e.onCompleted();\n          }\n\n          whenReady(e) {\n            const t = this;\n            t.isCompleted ? e() : (t.whenReadyCallbacks || (t.whenReadyCallbacks = []), t.whenReadyCallbacks.push(e));\n          }\n\n          whenRendered(e) {\n            const t = this;\n            t.isRendered ? e() : (t.whenRenderedCallbacks || (t.whenRenderedCallbacks = []), t.whenRenderedCallbacks.push(e));\n          }\n\n          addThemeClass() {\n            const e = this;\n            \"\" !== e.theme && e.classList.add(\"smart-\" + e.theme);\n          }\n\n          addDefaultClass() {\n            const e = this;\n            e.classList.add(n.toLowerCase() + \"-element\"), e.classList.add(e.nodeName.toLowerCase());\n          }\n\n          _renderShadowRoot() {\n            const e = this;\n\n            if (e.shadowRoot) {\n              e.$.root.classList.add(e.nodeName.toLowerCase());\n\n              for (let t = 0; t < e.attributes.length; t++) {\n                const n = e.attributes[t];\n                \"class\" === n.name || \"id\" === n.name || \"style\" === n.name || \"tabindex\" === n.name || n.name.indexOf(\"aria\") >= 0 || e.$.root.setAttribute(n.name, n.value);\n              }\n\n              for (let t = 0; t < e.classList.length; t++) {\n                const n = e.classList[t];\n                \"smart-element-init\" !== n && \"smart-element\" !== n && \"smart-hidden\" !== n && \"smart-visibility-hidden\" !== n && e.$.root.classList.add(n);\n              }\n            }\n          }\n\n          render() {\n            const e = this;\n\n            if (!e.isRendered && (e.isRendered = !0, e.isRendering = !1, e.context = document, e._renderShadowRoot(), e.whenRenderedCallbacks)) {\n              for (let t = 0; t < e.whenRenderedCallbacks.length; t++) e.whenRenderedCallbacks[t]();\n\n              e.whenRenderedCallbacks = [];\n            }\n\n            e.onRender && e.onRender(), e.disabled && e.setAttribute(\"aria-disabled\", !0), e.readonly && -1 !== [\"checkbox\", \"combobox\", \"grid\", \"gridcell\", \"listbox\", \"radiogroup\", \"slider\", \"spinbutton\", \"textbox\"].indexOf(e.getAttribute(\"role\")) && e.setAttribute(\"aria-readonly\", !0);\n          }\n\n          ready() {\n            const e = this;\n\n            if (e._setId(), e.addThemeClass(), e.addDefaultClass(), \"collapsed\" === e.visibility ? e.classList.add(\"smart-hidden\") : \"hidden\" === e.visibility && e.classList.add(\"smart-visibility-hidden\"), e.dataContext && e.applyDataContext(), e.onReady && e.onReady(), e.shadowRoot && Smart(e._selector)) {\n              if (Smart(e._selector).styleUrls) {\n                const t = Smart(e._selector).styleUrls;\n\n                for (let n = 0; n < t.length; n++) e.importStyle(t[n]);\n              }\n\n              if (Smart(e._selector).styles) {\n                const t = document.createElement(\"style\");\n                t.innerHTML = Smart(e._selector).styles, e.shadowRoot.insertBefore(t, e.shadowRoot.firstChild);\n              }\n            }\n\n            Smart(e._selector) && Smart(e._selector).ready && Smart(e._selector).ready();\n          }\n\n          _setId() {\n            const e = this;\n\n            if (!e.id) {\n              const t = e.elementName;\n              e.id = t.slice(0, 1).toLowerCase() + t.slice(1) + Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n            }\n          }\n\n          checkLicense() {\n            const e = this;\n            \"Evaluation\" === window[n].License && -1 === window.location.hostname.indexOf(\"htmlelements\") && (e.logWatermark(), e.logLicense(), window[n].License = \"\");\n          }\n\n          logWatermark() {\n            const e = document.createElement(\"a\");\n            e.href = \"https://www.htmlelements.com/\", e.innerHTML = \"https://www.htmlelements.com/\", e.style.position = \"absolute\", e.style.right = \"5px\", e.style.bottom = \"5px\", e.style.color = \"#fff\", e.style.padding = \"20px\", e.style.borderRadius = \"5px\", e.style.background = \"#0C3D78\", e.style.cursor = \"pointer\", e.style.zIndex = \"999999\", e.style.display = \"block\", e.style.fontSize = \"24px\", e.style.textDecoration = \"none\", e.style.fontWeight = \"bold\", e.style.opacity = 0, e.style.transition = \"opacity .35s ease-in-out\", e.id = \"watermark\", document.getElementById(\"watermark\") || setTimeout(() => {\n              document.getElementById(\"watermark\") || (document.body.appendChild(e), setTimeout(() => {\n                e.style.opacity = 1;\n              }), setTimeout(() => {\n                e.style.opacity = 0, setTimeout(() => {\n                  e.parentNode.removeChild(e);\n                }, 350);\n              }, 6e3));\n            }, 1e3);\n          }\n\n          logLicense() {\n            console.log(\"****************************************************************************************************************\"), console.log(\"****************************************************************************************************************\"), console.log(\"****************************************************************************************************************\"), console.log(\"*jQWidgets License Key Not Found.\"), console.log(\"*This is an EVALUATION only Version, it is NOT Licensed for software projects intended for PRODUCTION.\"), console.log(\"*if you want to hide this message, please send an email to: sales@jqwidgets.com for a license.\"), console.log(\"****************************************************************************************************************\"), console.log(\"****************************************************************************************************************\"), console.log(\"****************************************************************************************************************\");\n          }\n\n          get _selector() {\n            const e = this;\n            return e.id ? \"#\" + e.id : e.classList.length > 0 ? \".\" + e.classList[0] : \"\";\n          }\n\n          applyDataContext(e) {\n            const t = this;\n            let n = \"string\" == typeof t.dataContext ? window[t.dataContext] || document[t.dataContext] : t.dataContext;\n\n            if (e && (n = e, t.dataContext = e), n) {\n              if (!n._uid) {\n                n._uid = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(), n._properties = [];\n\n                for (let e in n) {\n                  const o = n[e];\n                  \"function\" != typeof o && \"_properties\" !== e && \"_uid\" !== e && (n._properties[e] = o, Object.defineProperty(n, e, {\n                    configurable: !1,\n                    enumerable: !0,\n                    get: () => n._properties[e],\n\n                    set(o) {\n                      const r = n._properties[e];\n                      n._properties[e] = o;\n                      let i = [];\n                      i[e] = {\n                        oldValue: r,\n                        value: o\n                      }, i.length++, t.updatingDataContext = !0, w.fireEvent(\"dataContextPropertyChanged\", {\n                        dataContext: n,\n                        properties: i\n                      }, {\n                        bubbles: !1,\n                        cancelable: !0\n                      }), t.updatingDataContext = !1;\n                    }\n\n                  }));\n                }\n              }\n\n              if (t.dataContextProperties = t.parseAttributes(t), t.dataContextPropertiesMap = {}, t.dataContextListeners = {}, t.dataContextProperties) {\n                t.updatingDataContext = !0;\n\n                for (let e in t.dataContextProperties) {\n                  const o = t.dataContextProperties[e],\n                        r = o.name;\n\n                  if (o.propertyName = e, t.dataContextPropertiesMap[r] = e, b.cache[\"toDash\" + e] || (b.cache[\"toDash\" + e] = y.Core.toDash(r)), o.isEvent) {\n                    const e = o.value;\n                    t.dataContextListeners[r] && t.removeEventListener(r, t.dataContextListeners[r]), t.dataContextListeners[r] = function (t) {\n                      n[e](t);\n                    }, t.addEventListener(r, t.dataContextListeners[r]);\n                  }\n\n                  if (r.indexOf(\".\") >= 0) {\n                    const o = r.split(\".\");\n                    let i = n[o[0]];\n\n                    for (let e = 1; e < o.length; e++) i = i[o[e]];\n\n                    void 0 !== i && (t[e] = i);\n                  } else t[e] = n[r];\n                }\n\n                t.dataContextPropertyChangedHandler = function (e) {\n                  const n = e.detail.properties;\n                  if (e.detail.dataContext === (\"string\" == typeof t.dataContext ? window[t.dataContext] || document[t.dataContext] : t.dataContext)) for (let e in n) {\n                    const o = t.dataContextPropertiesMap[e],\n                          r = t.context;\n                    o && (t.context = document, t[o] = n[e].value, t.context = r);\n                  }\n                }, w.listen(\"dataContextPropertyChanged\", t.dataContextPropertyChangedHandler), t.updatingDataContext = !1;\n              } else t.dataContextProperties = null;\n            } else {\n              t.dataContextProperties = null;\n\n              const e = function () {\n                (\"string\" == typeof t.dataContext ? window[t.dataContext] || document[t.dataContext] : t.dataContext) && (t.applyDataContext(), window.removeEventListener(\"load\", e));\n              };\n\n              window.addEventListener(\"load\", e);\n            }\n          }\n\n          updateDataContextProperty(e) {\n            const t = this,\n                  n = \"string\" == typeof t.dataContext ? window[t.dataContext] || document[t.dataContext] : t.dataContext,\n                  o = t.dataContextProperties[e];\n\n            if (!t.updatingDataContext && o.twoWay) {\n              const r = o.name;\n\n              if (r.indexOf(\".\") >= 0) {\n                const o = r.split(\".\");\n                let i = n[o[0]];\n\n                for (let e = 1; e < o.length; e++) i = i[o[e]];\n\n                void 0 !== i && (i = t[e], c[n._uid] && (c[n._uid][e] = i));\n              } else n[r] = t[e], c[n._uid] && (c[n._uid][e] = n[r]);\n            }\n          }\n\n          static get version() {\n            return window[n].Version;\n          }\n\n          initProperties() {\n            const e = this;\n\n            if (Smart(e._selector) && Smart(e._selector).properties && (e._initProperties = Smart(e._selector).properties), e.hasAttribute(\"props\") && !e.props ? e._initProperties = window[e.getAttribute(\"props\")] : e.props && (e._initProperties = e.props), e._initProperties) {\n              const t = Object.keys(e._initProperties);\n\n              for (let n = 0; n < t.length; n++) {\n                const o = t[n],\n                      r = e._initProperties[o];\n                if (r.constructor === Smart.ObservableArray || r instanceof Smart.ObservableArray) e[o] = r.toArray();else if (r.constructor === Smart.DataAdapter || \"smartDataAdapter\" === r.constructor.name || \"object\" == typeof r && Smart.DataAdapter && r instanceof Smart.DataAdapter || r instanceof Smart.Observable || r.constructor === Smart.Observable || \"object\" != typeof r || y.Types.isArray(r) || r instanceof Date) {\n                  if (void 0 === e[o] && -1 === [\"onReady\", \"onAttached\", \"onDetached\", \"onCreated\", \"onCompleted\"].indexOf(o)) {\n                    const t = e.localize(\"propertyUnknownName\", {\n                      name: o\n                    });\n                    e.log(t);\n                  }\n\n                  e[o] = r;\n                } else if (\"messages\" !== o && \"dataSourceMap\" !== o) {\n                  if (\"object\" == typeof r) {\n                    const t = function (n, o) {\n                      const r = Object.keys(n);\n\n                      for (let i = 0; i < r.length; i++) {\n                        const s = r[i],\n                              a = n[s],\n                              l = e._properties[o + \"_\" + s];\n\n                        if (l && null === l.value) {\n                          if (void 0 === e[o + \"_\" + s]) {\n                            const t = e.localize(\"propertyUnknownName\", {\n                              name: o + \"_\" + s\n                            });\n                            e.log(t);\n                          }\n\n                          e[o + \"_\" + s] = a;\n                        } else if (\"object\" == typeof a && !y.Types.isArray(a) && a && a.constructor !== Date) t(a, o + \"_\" + s);else {\n                          if (void 0 === e[o + \"_\" + s]) {\n                            const t = e.localize(\"propertyUnknownName\", {\n                              name: o + \"_\" + s\n                            });\n                            e.log(t);\n                          }\n\n                          e[o + \"_\" + s] = a;\n                        }\n                      }\n                    };\n\n                    t(r, o);\n                  }\n                } else e[o] = r;\n              }\n            }\n          }\n\n          setup() {\n            const e = this;\n            if (e.context = this, e.isReady && !e.isCompleted) return;\n            if (e.isReady) return e._setModuleState(\"attached\"), e.isAttached = !0, e.attached(), e._handleListeners(\"listen\"), void (e.context = document);\n            e.ownerElement && e.ownerElement.detachedChildren.indexOf(e) >= 0 && e.ownerElement.detachedChildren.splice(e.ownerElement.detachedChildren.indexOf(e), 1), e.isReady = !0, e.methods = e.getStaticMember(\"methods\"), e.initProperties(), a.isMobile && e.classList.add(\"smart-mobile\");\n\n            for (let t = 0; t < e.attributes.length; t += 1) {\n              const n = e.propertyByAttributeName[e.attributes[t].name];\n              if (!n) continue;\n              let o = e.$.getAttributeValue(n.attributeName, n.type);\n              const r = o ? o.toString() : \"\";\n\n              if (!(r.indexOf(\"{{\") >= 0 || r.indexOf(\"[[\") >= 0 || \"object\" !== n.type && \"array\" !== n.type && (e.attributes[t].value.indexOf(\"{{\") >= 0 || e.attributes[t].value.indexOf(\"[[\") >= 0) || void 0 === o || n.value === o)) {\n                const r = y.Types.getType(o),\n                      i = e.attributes[t].value;\n                if ((\"any\" === n.type || \"object\" === n.type) && \"\" + e[n.name] === o) continue;\n                if (\"array\" === n.type && e[n.name] && JSON.stringify(e[n.name]) === o) continue;\n\n                if (\"number\" === r && isNaN(o) && \"NaN\" !== i && \"Infinity\" !== i && \"-Infinity\" !== i) {\n                  const t = e.localize(\"propertyInvalidValueType\", {\n                    name: n.name,\n                    actualType: \"string\",\n                    type: n.type\n                  });\n                  e.log(t);\n                }\n\n                n.isUpdatingFromAttribute = !0, e[n.name] = o, n.isUpdatingFromAttribute = !1;\n              }\n            }\n\n            for (let t in e._properties) {\n              const n = e._properties[t];\n\n              if (\"innerHTML\" === t && n.value === n.defaultValue && (n.value = n.defaultValue = y.Core.html(e)), \"boolean\" !== n.type && \"bool\" !== n.type || \"false\" === e.getAttribute(n.attributeName) && (n.isUpdating = !0, e.setAttribute(n.attributeName, \"\"), n.isUpdating = !1), n.defaultReflectToAttribute && n.reflectToAttribute) {\n                if (n.defaultReflectToAttribute && n.defaultReflectToAttributeConditions) {\n                  let t = !0;\n\n                  for (let o = 0; o < n.defaultReflectToAttributeConditions.length; o++) {\n                    const r = n.defaultReflectToAttributeConditions[o];\n                    let i, s;\n\n                    for (let e in r) i = e, s = r[e];\n\n                    e._properties[i] && e._properties[i].value !== s && (t = !1);\n                  }\n\n                  if (!t) continue;\n                }\n\n                n.isUpdating = !0, e.$.setAttributeValue(n.attributeName, n.value, n.type), n.isUpdating = !1;\n              }\n            }\n\n            const t = [];\n            if (e.children.length > 0) for (let n = 0; n < e.children.length; n++) {\n              const o = e.children[n];\n              y.Extend(o).isCustomElement && t.push(o);\n            }\n            e.applyTemplate(), e.complete = function () {\n              if (!e.templateBindingsReady) {\n                const t = e => {\n                  e.templateBindingsReady || (e.templateBindingsReady = !0, e.updateTextNodes(), e.updateBoundNodes());\n                };\n\n                if (e.ownerElement) {\n                  let n = e.ownerElement,\n                      o = [];\n\n                  for (; n;) o.push(n), n = n.ownerElement;\n\n                  for (let e = o.length - 1; e >= 0; e--) t(o[e]);\n\n                  t(e);\n                } else t(e);\n              }\n\n              const t = () => {\n                if (e._setModuleState(\"ready\"), e.ready(), \"auto\" !== e.renderMode || e.isRendered || e.render(), e.isAttached = !0, e._setModuleState(\"attached\"), e.attached(), e._handleListeners(\"listen\"), e.isHidden || 0 !== e.offsetWidth && 0 !== e.offsetHeight || (e.isHidden = !0), e.completed(), e.isRendered && (e.context = document), e.whenReadyCallbacks) {\n                  for (let t = 0; t < e.whenReadyCallbacks.length; t++) e.whenReadyCallbacks[t]();\n\n                  e.whenReadyCallbacks = [];\n                }\n              };\n\n              if (e.wait) e.classList.add(\"smart-visibility-hidden\");else if (e.classList.contains(\"smart-async\")) requestAnimationFrame(() => {\n                t();\n              });else {\n                const n = e.shadowParent;\n                e.shadowParent = null;\n                const o = e.parents;\n                if (e.shadowParent = n, 0 === o.length) return;\n\n                const r = () => {\n                  let t = e.ownerElement,\n                      n = [];\n\n                  for (; t;) n.push(t), t = t.ownerElement;\n\n                  for (let e = n.length - 1; e >= 0; e--) n[e].updateBoundMappedNodes();\n                };\n\n                e.ownerElement && \"HTML\" !== o[o.length - 1].nodeName ? e.getRootNode().host ? t() : e.ownerElement && \"HTML\" === e.ownerElement.parents[e.ownerElement.parents.length - 1].nodeName ? (r(), t()) : e.checkIsInDomInterval = setInterval(() => {\n                  const n = e.parents;\n                  \"HTML\" === n[n.length - 1].nodeName && (clearInterval(e.checkIsInDomInterval), r(), t());\n                }, 100) : t();\n              }\n            };\n            let o = [].slice.call(e.querySelectorAll(\"[smart-id]\")).concat(t);\n            if (window[n].EnableShadowDOM && !0 !== e.isInShadowDOM && (o = [].slice.call(e.shadowRoot.querySelectorAll(\"[smart-id]\")).concat(t)), 0 === o.length) e.complete();else {\n              e._completeListeners = 0;\n\n              for (let t = 0; t < o.length; t++) {\n                const n = o[t];\n\n                if (y.Extend(n).isCustomElement) {\n                  const t = function () {\n                    e._completeListeners--, 0 === e._completeListeners && (e.complete(), delete e._completeListeners);\n                  }.bind(e);\n\n                  n.isCompleted || n.isUtilityElement || !0 === n.wait || (e._completeListeners++, n._onCompleted || (n.completeHandlers = [], n._onCompleted = function () {\n                    for (let e = 0; e < n.completeHandlers.length; e++) n.completeHandlers[e]();\n                  }), n.completeHandlers.push(t));\n                }\n              }\n\n              0 === e._completeListeners && e.complete();\n            }\n          }\n\n          visibilityChangedHandler() {\n            const e = this;\n            e.isReady && requestAnimationFrame(() => {\n              0 === e.offsetWidth || 0 === e.offsetHeight ? e.isHidden = !0 : (e.isHidden = !1, e.$.fireEvent(\"resize\", e, {\n                bubbles: !1,\n                cancelable: !0\n              }));\n            });\n          }\n\n          attributeChangedCallback(e, t, n) {\n            const o = this,\n                  r = o.propertyByAttributeName[e];\n            if (\"class\" !== e && \"style\" !== e || o.visibilityChangedHandler(), r || o.attributeChanged(e, t, n), o.onAttributeChanged && o.onAttributeChanged(e, t, n), !r || r && r.isUpdating) return;\n            let i = o.$.getAttributeValue(r.attributeName, r.type);\n            void 0 !== n && o[r.name] !== i && (r.isUpdatingFromAttribute = !0, o[r.name] = void 0 !== i ? i : o._properties[r.name].defaultValue, r.isUpdatingFromAttribute = !1);\n          }\n\n          attributeChanged(e, t, n) {}\n\n          set hasStyleObserver(e) {\n            const t = this;\n            void 0 === t._hasStyleObserver && (t._hasStyleObserver = e), e ? d.watch(t) : d.unwatch(t);\n          }\n\n          get hasStyleObserver() {\n            const e = this;\n            return void 0 === e._hasStyleObserver || e._hasStyleObserver;\n          }\n\n          attached() {\n            const e = this;\n            e.hasStyleObserver && d.watch(e), e.onAttached && e.onAttached(), Smart(e._selector) && Smart(e._selector).attached && Smart(e._selector).attached();\n          }\n\n          detached() {\n            const e = this;\n            e.hasStyleObserver && d.unwatch(e), e._setModuleState(\"detached\"), e.isAttached = !1, e.ownerElement && -1 === e.ownerElement.detachedChildren.indexOf(e) && e.ownerElement.detachedChildren.push(e), e._handleListeners(\"unlisten\"), e.onDetached && e.onDetached(), Smart(e._selector) && Smart(e._selector).detached && Smart(e._selector).detached(), u && u[e._selector] && delete u[e._selector];\n          }\n\n          propertyChangedHandler(e, t, n) {\n            const o = this;\n            t !== n && (\"theme\" === e && (\"\" !== t && o.classList.remove(\"smart-\" + t), \"\" !== n && o.classList.add(\"smart-\" + n)), \"visibility\" === e ? (\"collapsed\" === t ? o.classList.remove(\"smart-hidden\") : \"hidden\" === t && o.classList.remove(\"smart-visibility-hidden\"), \"collapsed\" === n ? o.classList.add(\"smart-hidden\") : \"hidden\" === n && o.classList.add(\"smart-visibility-hidden\")) : (\"disabled\" === e || \"readonly\" === e) && o._ariaPropertyChangedHandler(e, n), o.propertyChanged && o.propertyChanged(e, t, n));\n          }\n\n          _ariaPropertyChangedHandler(e, t) {\n            const n = this;\n            \"readonly\" === e && -1 === [\"checkbox\", \"combobox\", \"grid\", \"gridcell\", \"listbox\", \"radiogroup\", \"slider\", \"spinbutton\", \"textbox\"].indexOf(n.getAttribute(\"role\")) || (t ? n.setAttribute(\"aria-\" + e, !0) : n.removeAttribute(\"aria-\" + e));\n          }\n\n          _handleListeners(e) {\n            const t = this,\n                  n = t.tagName.toLowerCase(),\n                  o = o => {\n              for (let r in o) {\n                const i = r.split(\".\");\n                let s = i[0],\n                    a = t.$;\n                if (i[1]) {\n                  if (s = i[1], a = t[\"$\" + i[0]], \"document\" === i[0]) {\n                    let e = t.smartId;\n                    \"\" === e && (e = y.Core.toCamelCase(n)), s = s + \".\" + e;\n                  } else t.smartId && (s = s + \".\" + t.smartId + \"_\" + t.parents.length);\n                } else t.smartId && (s = s + \".\" + t.smartId);\n\n                const l = o[r],\n                      d = function (e) {\n                  const n = t.context;\n                  t.context = t, t[l] && t[l].apply(t, [e]), t.context = n;\n                };\n\n                a && a[e](s, d);\n              }\n            };\n\n            o(t.getStaticMember(\"listeners\")), o(t.templateListeners), Smart(t._selector) && Smart(t._selector).properties && o(Smart(t._selector).listeners);\n          }\n\n          parseTemplate() {\n            const e = this,\n                  n = e.template(),\n                  r = document.createDocumentFragment();\n            if (t[e.nodeName] && !o) return t[e.nodeName].cloneNode(!0);\n            if (\"\" === n) return null;\n            let i = document.createElement(\"div\");\n            r.appendChild(i), i.innerHTML = n;\n            let s = i.childNodes;\n            i.parentNode.removeChild(i);\n\n            for (let e = 0; e < s.length; e++) r.appendChild(s[e]);\n\n            return t[e.nodeName] = r, o ? r : r.cloneNode(!0);\n          }\n\n          applyTemplate() {\n            const e = this,\n                  t = e.parseTemplate();\n            if (!t) return;\n            if (!t.hasChildNodes) return;\n\n            const n = t.childNodes[0],\n                  o = (t, n) => {\n              e[\"$\" + t] = n.$ = y.Extend(n), e.$[t] = n, n.ownerElement = e;\n            };\n\n            let r = n;\n\n            if (n.getElementsByTagName(\"content\").length > 0) {\n              let e = n.getElementsByTagName(\"content\")[0];\n              r = e.parentNode, r.removeChild(e);\n            } else {\n              const e = t.querySelectorAll(\"[inner-h-t-m-l]\");\n              e && e.length > 0 && (r = e[0]);\n            }\n\n            e.$.template = \"template\" === n.nodeName.toLowerCase() ? n : n.querySelector(\"template\");\n            let i = t.querySelectorAll(\"[id]\");\n            0 === i.length && (i = t.querySelectorAll(\"*\")), o(\"root\", n), o(\"content\", r), e.$.html = e.innerHTML.toString().trim();\n\n            for (let t = 0; t < i.length; t += 1) {\n              let n = i[t];\n              \"\" === n.id && (n.id = \"child\" + t), o(n.id, n), n.setAttribute(\"smart-id\", n.id), e.shadowRoot ? n.shadowParent = e : n.removeAttribute(\"id\");\n            }\n\n            for (!1 !== e.hasTemplateBindings ? e.bindings = e.getBindings(t) : e.bindings = [], e.$root.addClass(\"smart-container\"); e.childNodes.length;) r.appendChild(e.firstChild);\n\n            if (e.appendTemplate(t), e.$.template) {\n              const t = document.createElement(\"div\");\n              t.classList.add(\"smart-template-container\"), e.$.templateContainer = t, e.$.template.parentNode.insertBefore(t, e.$.template), e.refreshTemplate();\n            }\n          }\n\n          refreshTemplate() {\n            const e = this;\n            if (!e.$.templateContainer) return;\n            e.templateDetached(e.$.templateContainer);\n            const t = e.$.template.content.cloneNode(!0);\n            e.templateBindings = e.getBindings(t), e.templateProperties = [];\n            let n = document.createDocumentFragment();\n\n            const o = function (t, n, r) {\n              for (let i in t) {\n                const s = t[i],\n                      a = s.node.cloneNode();\n                n.appendChild(a);\n                let l = [],\n                    d = !1;\n                if (s.data) for (let t in s.data) {\n                  const o = s.data[t],\n                        i = o.name;\n                  if (e.templateProperties[i] = !0, a.removeAttribute(y.Core.toDash(t)), \"*items\" === t) l = e[i], d = !0;else if (i.indexOf(\"item.\") >= 0 && void 0 !== r) o.value = r[i.substring(\"item.\".length)], a[t] = o.value;else if (i.indexOf(\"item\") >= 0 && void 0 !== r) o.value = r, a[t] = o.value;else if (\"*if\" === t) {\n                    if (i.indexOf(\"(\") >= 0) {\n                      let t,\n                          o = i.substring(i.indexOf(\"(\"));\n                      const r = i.substring(0, i.indexOf(\"(\"));\n\n                      if (o = o.substring(1, o.length - 1), o = o.replace(/ /gi, \"\"), o = o.split(\",\"), o.length > 0 && \"\" !== o[0]) {\n                        let n = [];\n\n                        for (let t = 0; t < o.length; t++) n.push(e[o[t]]);\n\n                        t = e[r].apply(e, n);\n                      } else t = e[r]();\n\n                      !1 === t && n.removeChild(a);\n                    } else e[i] || n.removeChild(a);\n                  } else e.updateBoundNode(a, s, e, i);\n                }\n\n                if (l.length > 0 || d) {\n                  for (let e = 0; e < l.length; e++) s.children && o(s.children, a, l[e]);\n\n                  if (\"number\" == typeof l) for (let e = 0; e < l; e++) s.children && o(s.children, a, e);\n                } else s.children && o(s.children, a, r);\n              }\n            };\n\n            o(e.templateBindings.children, n), e.$.templateContainer.innerHTML = \"\", e.$.templateContainer.appendChild(n), e.templateAttached(e.$.templateContainer);\n          }\n\n          templateAttached() {}\n\n          templateDetached() {}\n\n          appendTemplate(e) {\n            this.appendChild(e);\n          }\n\n          defineElementModules() {\n            const e = this,\n                  t = e.constructor.prototype;\n\n            if (\"BaseElement\" === t.elementName) {\n              t.modules = e.constructor.modules;\n              const n = t.modules;\n\n              for (let t = 0; t < n.length; t += 1) e.addModule(n[t]);\n            } else {\n              const n = t.modules;\n              if (!n) return;\n\n              for (let t = 0; t < n.length; t += 1) {\n                const o = n[t],\n                      r = o.prototype;\n                e.defineElementMethods(r.methodNames, r), e.defineElementProperties(o.properties);\n              }\n            }\n          }\n\n          watch(e, t) {\n            const n = this;\n            n._watch = null !== e && null !== t ? {\n              properties: e,\n              propertyChangedCallback: t\n            } : null;\n          }\n\n          unwatch() {\n            this._watch = null;\n          }\n\n          set(e, t, n) {\n            const o = this,\n                  r = o.context;\n            o.context = !0 === n ? document : o, o[e] = t, o.context = r;\n          }\n\n          get(e) {\n            return this[e];\n          }\n\n          _setModuleState(e, t) {\n            const n = this,\n                  o = \"is\" + e.substring(0, 1).toUpperCase() + e.substring(1),\n                  r = \"on\" + e.substring(0, 1).toUpperCase() + e.substring(1);\n\n            for (let i = 0; i < n.modulesList.length; i++) {\n              const s = n.modulesList[i];\n              s[o] = !0, s[e] && s[e](t), s[r] && s[r](t);\n            }\n          }\n\n          addModule(e, t) {\n            const n = this;\n            if (!e) return;\n            const o = n.modules.slice(0),\n                  r = e.prototype,\n                  i = Object.getPrototypeOf(e);\n            if (i.name && i.name !== e.name && n.addModule(i), !e.moduleName && e.name && (e.moduleName = e.name), -1 === o.findIndex(t => e.moduleName === t.moduleName) && o.push(e), n.defineModule(e), n.defineElementMethods(r.methodNames, r), n.defineElementProperties(e.properties), n.constructor.prototype.modules = o, t) for (let t in Smart.Elements.tagNames) {\n              const o = Smart.Elements.tagNames[t];\n              let r = Object.getPrototypeOf(o),\n                  i = [];\n\n              for (; r !== HTMLElement;) i.push(r.prototype), r = Object.getPrototypeOf(r);\n\n              i.indexOf(n) >= 0 && o !== n && o.prototype.addModule(e);\n            }\n          }\n\n          defineModule(e) {\n            if (e.isDefined) return;\n\n            e.prototype._initModule = function (e) {\n              this.ownerElement = e;\n            };\n\n            const t = e.properties || {},\n                  n = Object.keys(t),\n                  o = Object.getOwnPropertyNames(e.prototype);\n            e.prototype.methodNames = o;\n\n            for (let o = 0; o < n.length; o += 1) {\n              const r = n[o],\n                    i = t[r];\n              Object.defineProperty(e.prototype, r, {\n                configurable: !1,\n                enumerable: !0,\n\n                get() {\n                  return this.ownerElement ? this.ownerElement[r] : i.value;\n                },\n\n                set(e) {\n                  this.ownerElement[r] = e;\n                }\n\n              });\n            }\n\n            e.isDefined = !0;\n          }\n\n          getStaticMember(e, t) {\n            const o = window[n][this.elementName],\n                  r = o[e];\n            t || (t = \"\");\n            let i = \"array\" === t ? [] : \"string\" === t ? \"\" : {},\n                s = Object.getPrototypeOf(o),\n                a = [];\n\n            for (; s[e];) a.push(s[e]), s = Object.getPrototypeOf(s);\n\n            for (let e = a.length - 1; e >= 0; e--) if (\"array\" === t) for (let t = 0; t < a[e].length; t++) -1 === i.indexOf(a[e][t]) && i.push(a[e][t]);else \"string\" === t ? -1 === i.indexOf(a[e]) && (i += a[e]) : i = y.Core.assign(i, a[e]);\n\n            if (\"array\" === t) {\n              for (let e = 0; e < r.length; e++) -1 === i.indexOf(r[e]) && i.push(r[e]);\n\n              return i;\n            }\n\n            return \"string\" === t ? (-1 === i.indexOf(r) && (i += r), i) : y.Core.assign(i, r);\n          }\n\n          defineElementHierarchicalProperties(e, t) {\n            const n = this,\n                  o = [];\n            !function (e) {\n              const n = Object.keys(e);\n\n              for (let r = 0; r < n.length; r++) {\n                const i = n[r];\n                if (\"messages\" === i) continue;\n                const s = e[i],\n                      a = Object.keys(s),\n                      l = a.indexOf(\"value\") >= 0 && a.indexOf(\"type\") >= 0 && \"object\" == typeof s.value;\n\n                if (\"propertyObject\" === s.type || l) {\n                  const e = function (n, r) {\n                    if (!n.value) return;\n                    const i = Object.keys(n.value);\n\n                    for (let s = 0; s < i.length; s++) {\n                      const a = i[s],\n                            l = n.value[a],\n                            d = r + \"_\" + a;\n                      if (\"object\" != typeof l || null === l) break;\n                      const c = Object.keys(l);\n                      if (!(c.indexOf(\"value\") >= 0 && c.indexOf(\"type\") >= 0)) break;\n\n                      if (\"array\" !== n.type && (n.isHierarchicalProperty = !0), l.parentPropertyName = r, t) {\n                        const e = t._properties[d];\n\n                        if (n.value.hasOwnProperty(a)) {\n                          if (e.isDefined) continue;\n                          delete n.value[a];\n                        }\n\n                        e.isDefined = !0, Object.defineProperty(n.value, a, {\n                          configurable: !1,\n                          enumerable: !0,\n                          get: () => t._properties[d].value,\n\n                          set(e) {\n                            t.updateProperty(t, t._properties[d], e);\n                          }\n\n                        });\n                      }\n\n                      o[d] || (o[d] = l, o.length++), (\"propertyObject\" === l.type || \"object\" == typeof l.value && \"array\" !== l.type) && e(t ? t._properties[d] : l, d);\n                    }\n                  };\n\n                  e(s, i);\n                }\n              }\n            }(e), o.length > 0 && !t && n.defineElementProperties(o);\n          }\n\n          defineElement() {\n            const e = this,\n                  t = e.constructor.prototype,\n                  n = e.getStaticMember(\"properties\"),\n                  o = Object.getOwnPropertyNames(t);\n            t.extendedProperties = {}, t.boundProperties = {}, t.templateListeners = {}, e.defineElementModules(), e.defineElementMethods(o, t), e.defineElementProperties(n), e.defineElementHierarchicalProperties(e.extendedProperties), t._initElement = function () {\n              const e = this,\n                    n = t.extendedProperties,\n                    o = Object.keys(n),\n                    r = e.modules;\n              e.$ = y.Extend(e), e.$document = w, e.smartId = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(), e.isCreated || (e.modulesList = [], e._properties = [], e._beforeCreatedProperties && (e._properties = e._beforeCreatedProperties, delete e._beforeCreatedProperties), e.detachedChildren = [], e.propertyByAttributeName = []);\n\n              for (let t = 0; t < r.length; t += 1) {\n                let n = new (0, r[t])();\n                n._initModule(e), e.modulesList.push(n);\n              }\n\n              for (let t = 0; t < o.length; t += 1) {\n                const r = o[t],\n                      i = n[r];\n                let s = i.value;\n\n                if (e._properties[r]) {\n                  if (void 0 !== e._properties[r].notify) continue;\n                  delete e._properties[r];\n                }\n\n                if (E && \"innerHTML\" === r && delete e[r], -1 === window.navigator.userAgent.indexOf(\"PhantomJS\") && e.hasOwnProperty(r) && (s = e[r], delete e[r]), \"array\" === i.type && null != s && (s = s.slice(0)), \"object\" === i.type && null != s && (s = Array.isArray(s) ? s.slice(0) : Object.assign({}, s)), e._properties[r] = {\n                  name: r,\n                  notify: i.notify,\n                  allowedValues: i.allowedValues,\n                  type: i.type,\n                  nullable: i.nullable,\n                  reflectToAttribute: i.reflectToAttribute,\n                  defaultReflectToAttribute: i.defaultReflectToAttribute,\n                  defaultReflectToAttributeConditions: i.defaultReflectToAttributeConditions,\n                  value: s,\n                  readOnly: i.readOnly,\n                  defaultValue: s,\n                  attributeName: i.attributeName,\n                  observer: i.observer,\n                  inherit: i.inherit,\n                  extend: i.extend,\n                  validator: i.validator\n                }, e.propertyByAttributeName[i.attributeName] = e._properties[r], !i.hasOwnProperty(\"type\")) {\n                  const t = e.localize(\"propertyUnknownType\", {\n                    name: r\n                  });\n                  e.log(t);\n                }\n\n                if (\"any\" === i.type || \"propertyObject\" === i.type) continue;\n                const a = y.Types.getType(s);\n\n                if (null != s && i.type !== a && !i.validator) {\n                  if (\"object\" === i.type && \"array\" === a) continue;\n                  if (\"number\" === a && [\"integer\", \"int\", \"float\"].findIndex(e => e === i.type) >= 0) continue;\n                  const t = e.localize(\"propertyInvalidValueType\", {\n                    name: r,\n                    actualType: a,\n                    type: i.type\n                  });\n                  e.log(t);\n                }\n              }\n\n              e.defineElementHierarchicalProperties(e._properties, e), e.isCreated = !0;\n            }, t.registered();\n          }\n\n          defineElementMethods(e, t) {\n            const n = this.constructor.prototype,\n                  o = function (e, t) {\n              const n = Array.prototype.slice.call(arguments, 2),\n                    o = function () {\n                if (!this.isReady && \"localize\" !== t && \"localize\" !== t && \"cloneNode\" !== t && \"importStyle\" !== t && \"log\" !== t && \"parseAttributes\" !== t) {\n                  const e = this.localize(\"elementNotInDOM\");\n                  this.log(e);\n                }\n\n                let o = this;\n\n                for (let e = 0; e < this.modulesList.length; e++) {\n                  let n = this.modulesList[e];\n\n                  if (t in n) {\n                    o = n;\n                    break;\n                  }\n                }\n\n                const r = this.context,\n                      i = n.concat(Array.prototype.slice.call(arguments));\n                let s = null;\n\n                const a = function (e, t) {\n                  return e === t || \"number\" === e && (\"int\" === t || \"integer\" === t || \"float\" === t) || \"bool\" === e && \"boolean\" === t || \"boolean\" === e && \"bool\" === t || \"object\" === e && \"any\" === t || void 0;\n                };\n\n                if (this.methods) {\n                  const e = this.methods[t];\n\n                  if (e) {\n                    const n = e.split(\":\");\n                    s = n[n.length - 1].trim();\n                    const o = [],\n                          r = e.substring(1 + e.indexOf(\"(\"), e.lastIndexOf(\")\")).split(\",\");\n                    let l = \"\";\n\n                    for (let e = 0; e < r.length; e++) {\n                      const t = r[e];\n                      l += t, t.indexOf(\":\") >= 0 ? (o.push(l), l = \"\") : l += \",\";\n                    }\n\n                    let d = o.length;\n\n                    for (let e = 0; e < o.length; e++) {\n                      const n = o[e].trim().split(\":\"),\n                            r = n[0].split(\"=\")[0].trim().indexOf(\"?\") >= 0,\n                            s = n[1].indexOf(\"?\") >= 0,\n                            l = n[1].replace(/\\?/gi, \"\").trim(),\n                            c = l.split(\"|\");\n                      let u = n[0].split(\"=\")[1];\n                      const p = y.Types.getType(i[e]);\n\n                      if (void 0 === i[e] && u) {\n                        switch (u = u.trim(), l[0]) {\n                          case \"date\":\n                            {\n                              let e = u.substring(u.indexOf(\"(\") + 1, u.lastIndexOf(\")\"));\n                              e = e.length > 0 ? e.split(\",\").map(e => parseInt(e)) : [], u = 0 === e.length ? new Date() : new Date(e[0], e[1], e[2]);\n                              break;\n                            }\n\n                          case \"bool\":\n                          case \"boolean\":\n                            u = \"true\" === u || \"1\" === u;\n                            break;\n\n                          case \"int\":\n                          case \"integer\":\n                            u = parseInt(u);\n                            break;\n\n                          case \"float\":\n                          case \"number\":\n                            u = parseFloat(u);\n                            break;\n\n                          case \"any\":\n                          case \"object\":\n                            u = u.indexOf(\"{\") >= 0 ? JSON.parse(u) : u;\n                        }\n\n                        i.push(u);\n                      } else r && d--;\n\n                      if (l !== p && p) {\n                        let n = !0;\n\n                        for (let e = 0; e < c.length; e++) if (a(p, c[e])) {\n                          n = !1;\n                          break;\n                        }\n\n                        if (n && (null !== i[e] || !s)) {\n                          const n = this.localize(\"methodInvalidValueType\", {\n                            name: t,\n                            actualType: p,\n                            type: l,\n                            argumentIndex: e\n                          });\n                          this.log(n);\n                        }\n                      }\n\n                      if (i.length < d) {\n                        const e = this.localize(\"methodInvalidArgumentsCount\", {\n                          name: t,\n                          actualArgumentsCount: i.length,\n                          argumentsCount: d\n                        });\n                        this.log(e);\n                      }\n                    }\n                  }\n                }\n\n                this.context = this;\n                const l = e.apply(o, i);\n\n                if (s) {\n                  const e = void 0 === y.Types.getType(l) ? \"void\" : y.Types.getType(l);\n\n                  if (!a(e, s)) {\n                    const n = this.localize(\"methodInvalidReturnType\", {\n                      name: t,\n                      actualType: e,\n                      type: s\n                    });\n                    this.log(n);\n                  }\n                }\n\n                return this.context = r, l;\n              };\n\n              return o;\n            },\n                  r = [\"constructor\", \"ready\", \"created\", \"render\", \"attached\", \"detached\", \"appendChild\", \"insertBefore\", \"removeChild\", \"connect\", \"disconnectedCallback\", \"connectedCallback\", \"attributeChangedCallback\", \"propertyChangedHandler\", \"enableShadowDOM\", \"isInShadowDOM\", \"addPropertyBindings\"];\n\n            for (let i in e) {\n              let s = e[i];\n              s.startsWith(\"_\") || void 0 !== r.find(e => e === s) || n.extendedProperties[s] || y.Types.isFunction(t[s]) && (n[s] = o(t[s], s));\n            }\n          }\n\n          defineElementProperties(e) {\n            if (!e) return;\n            const t = this,\n                  n = t.constructor.prototype,\n                  o = Object.keys(e),\n                  r = t.getStaticMember(\"properties\");\n            Object.assign(n.extendedProperties, e), t.updateProperty = function (e, t, n) {\n              const o = e;\n              if (!t || t.readOnly) return;\n\n              if (t.allowedValues) {\n                let e = !1;\n\n                for (let o = 0; o < t.allowedValues.length; o++) if (t.allowedValues[o] === n) {\n                  e = !0;\n                  break;\n                }\n\n                if (!e) {\n                  const e = JSON.stringify(t.allowedValues).replace(/\\[|\\]/gi, \"\").replace(\",\", \", \").replace(/\"/gi, \"'\"),\n                        r = \"'\" + n + \"'\",\n                        i = o.localize(\"propertyInvalidValue\", {\n                    name: t.name,\n                    actualValue: r,\n                    value: e\n                  });\n                  return void o.log(i);\n                }\n              }\n\n              const r = t.name,\n                    i = o._properties[r].value;\n\n              if (t.validator && o[t.validator]) {\n                const e = o.context;\n                o.context = o;\n                const r = o[t.validator](i, n);\n                void 0 !== r && (n = r), o.context = e;\n              }\n\n              if (i !== n) {\n                if (o.propertyChanging) {\n                  const e = o.propertyChanging(r, i, n);\n                  if (!1 === e || null === e) return;\n                }\n\n                if (!t.hasOwnProperty(\"type\")) {\n                  const e = o.localize(\"propertyUnknownType\", {\n                    name: r\n                  });\n                  o.log(e);\n                }\n\n                if (\"array\" !== t.type || JSON.stringify(i) !== JSON.stringify(n)) {\n                  if (null != n && \"any\" !== t.type && \"propertyObject\" !== t.type && t.type !== y.Types.getType(n) && !t.validator || null === n && !t.nullable) {\n                    let e = !0;\n\n                    if (\"object\" === t.type && \"array\" === y.Types.getType(n) && (e = !1), \"number\" === y.Types.getType(n) && [\"integer\", \"int\", \"float\"].findIndex(e => e === t.type) >= 0 && (e = !1), e) {\n                      const e = o.localize(\"propertyInvalidValueType\", {\n                        name: r,\n                        actualType: y.Types.getType(n),\n                        type: t.type\n                      });\n                      return void o.error(e);\n                    }\n                  }\n\n                  if (t.isUpdating = !0, t.isHierarchicalProperty) {\n                    const e = function (t, n) {\n                      const r = Object.keys(t);\n\n                      for (let i = 0; i < r.length; i++) {\n                        const s = r[i],\n                              a = t[s];\n                        \"object\" == typeof a && !y.Types.isArray(a) && a && a.constructor !== Date ? e(a, n + \"_\" + s) : o[n + \"_\" + s] = a;\n                      }\n                    };\n\n                    e(n, r);\n                  } else o._properties[r].value = n;\n\n                  if (!t.isUpdatingFromAttribute && t.reflectToAttribute && o.$.setAttributeValue(t.attributeName, n, t.type), o.isReady && (!o.ownerElement || o.ownerElement && o.ownerElement.isReady)) {\n                    if (\"wait\" === r && (n || !i || o.isCompleted || (o.classList.remove(\"smart-visibility-hidden\"), o.ownerElement && o.ownerElement.updateBoundMappedNodes(), o.updateBoundMappedNodes(), o.complete())), \"renderMode\" === r) return;\n\n                    if (o.context !== o && !o.wait) {\n                      const e = o.context;\n                      o.context = o, o.propertyChangedHandler(r, i, n), o.context = e, t.observer && o[t.observer] && (o.context = o, o[t.observer](i, n), o.context = document), o._watch && o._watch.properties.indexOf(r) >= 0 && o._watch.propertyChangedCallback(r, i, n);\n                    }\n\n                    const e = t.notify || o.boundProperties[r];\n                    e && (o.$.fireEvent(t.attributeName + \"-changed\", {\n                      context: o.context,\n                      oldValue: i,\n                      value: o[r]\n                    }), o.boundProperties[r] && o.updateBoundNodes(r)), e && o.templateProperties && o.templateProperties[r] && o.refreshTemplate(), o.dataContextProperties && (\"dataContext\" === r ? o.applyDataContext() : o.dataContextProperties[r] && o.updateDataContextProperty(r));\n                  }\n\n                  t.isUpdating = !1;\n                }\n              }\n            };\n\n            for (let t = 0; t < o.length; t += 1) {\n              const i = o[t],\n                    s = e[i],\n                    a = y.Core.toDash(i),\n                    l = s.type || \"any\",\n                    d = l.indexOf(\"?\") >= 0 || \"any\" === l;\n              d && \"any\" !== l && (s.type = l.substring(0, l.length - 1)), s.nullable = d, s.attributeName = a.toLowerCase(), s.name = i, s.reflectToAttribute = void 0 === s.reflectToAttribute || s.reflectToAttribute, s.inherit && r[i] && (s.value = r[i].value), s.extend && r[i] && y.Core.assign(s.value, r[i].value), n.hasOwnProperty(i) || Object.defineProperty(n, i, {\n                configurable: !1,\n                enumerable: !0,\n\n                get() {\n                  if (this._properties[i]) return this._properties[i].value;\n                },\n\n                set(e) {\n                  const t = this;\n                  t.updateProperty(t, t._properties[i], e);\n                }\n\n              });\n            }\n          }\n\n        }\n\n        let _ = [],\n            S = [],\n            x = [],\n            E = !1;\n        const A = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n        A && parseInt(A[2], 10) <= 50 && (E = !0);\n\n        class P {\n          static register(e, t) {\n            const o = t.prototype;\n            let r = a.toCamelCase(e).replace(/[a-z]+/, \"\"),\n                i = t.version || window[n].Version;\n            if (window.customElements.get(e) && window.customElements.get(e).version === i) return;\n            let s = e;\n\n            for (i = i.split(\".\"); window.customElements.get(e);) e = s + \"-\" + i.join(\".\"), i[2] = parseInt(i[2]) + 1;\n\n            if (!_[e]) {\n              if (e.startsWith(n.toLowerCase())) _[e] = window[n][r] = window[n.toLowerCase() + r] = t;else {\n                let o = e.split(\"-\")[0];\n                o = o.substring(0, 1).toUpperCase() + o.substring(1), window[n][o] || (window[n][o] = {}), _[e] = window[n][o][r] = window[o.toLowerCase() + r] = t, window[n][r] && (r = a.toCamelCase(e)), window[n][r] = t;\n              }\n              o.elementName = r, o.defineElement(), S[e] && S[e](o), window.customElements.define(e, t);\n            }\n          }\n\n          static registerElements() {\n            const e = this;\n\n            if (e.toRegister) {\n              e.isRegistering = !0;\n\n              for (let t = 0; t < e.toRegister.length; t++) {\n                const n = e.toRegister[t];\n                e.register(n.tagName, n.element);\n              }\n\n              e.isRegistering = !1;\n            }\n          }\n\n          static get(e) {\n            if (_[e]) return _[e];\n          }\n\n          static whenRegistered(e, t) {\n            if (!e) throw new Error(\"Syntax Error: Invalid tag name\");\n            const n = S[e],\n                  o = this.get(e),\n                  r = o ? o.modules.length : 3;\n\n            try {\n              n || o ? !n && o ? (t(o.prototype), S[e] = void 0) : n && !o ? S[e] = function (e) {\n                n(e), t(e);\n              } : n && o && (o.proto && (n(o.proto), t(o.proto)), S[e] = void 0) : S[e] = function (e) {\n                try {\n                  t(e);\n                } catch (e) {\n                  const t = e instanceof Error ? e.message : e.toString();\n                  console.log(t);\n                }\n              };\n            } catch (e) {\n              const t = e instanceof Error ? e.message : e.toString();\n              console.log(t);\n            }\n\n            if (o && r !== o.prototype.modules.length) {\n              const t = document.querySelectorAll(e);\n\n              for (let e = 0; e < t.length; e++) {\n                const n = t[e];\n                n.isCreated && n._initElement();\n              }\n            }\n          }\n\n        }\n\n        P.lazyRegister = !1, P.tagNames = [];\n\n        class L {\n          constructor() {\n            const e = this;\n            e.name = \"observableArray\", e.observables = arguments.length < 3 ? null : arguments[2];\n            const t = new Proxy(e, {\n              deleteProperty: function (e, t) {\n                return delete e[t], !0;\n              },\n              apply: function (e, t, n) {\n                return e.apply(t, n);\n              },\n              get: function (t, n) {\n                return t[n] || isNaN(parseInt(n)) ? t[n] : e.getItem(parseInt(n));\n              },\n              set: function (t, n, o) {\n                return t[n] || isNaN(parseInt(n)) ? (t[n] = o, !0) : (e.setItem(parseInt(n), o), !0);\n              }\n            });\n\n            if (e._addArgs = {\n              eventName: \"change\",\n              object: t,\n              action: \"add\",\n              index: null,\n              removed: new Array(),\n              addedCount: 1\n            }, e._removeArgs = {\n              eventName: \"change\",\n              object: t,\n              action: \"remove\",\n              index: null,\n              removed: null,\n              addedCount: 0\n            }, arguments.length >= 1 && Array.isArray(arguments[0])) {\n              e._array = [];\n              const t = arguments[0];\n\n              for (let n = 0, o = t.length; n < o; n++) {\n                const o = e._getItem(e._array.length, t[n]);\n\n                e._array.push(o);\n              }\n            } else e._array = Array.apply(null, arguments);\n\n            return 2 === arguments.length && (e.notifyFn = arguments[1]), t;\n          }\n\n          get canNotify() {\n            const e = this;\n            return void 0 === e._canNotify && (e._canNotify = !0), e._canNotify;\n          }\n\n          set canNotify(e) {\n            this._canNotify = e;\n          }\n\n          _notify(e) {\n            const t = this;\n            t.canNotify && t.notifyFn && t.notifyFn(e);\n          }\n\n          notify(e) {\n            e && (this.notifyFn = e);\n          }\n\n          toArray() {\n            return this._array;\n          }\n\n          _getItem(e, t) {\n            const n = this;\n            return \"string\" == typeof t || \"number\" == typeof t || void 0 === t ? t : new Proxy(t, {\n              deleteProperty: function (e, t) {\n                return delete e[t], !0;\n              },\n              set: function (t, o, r) {\n                const i = t[o];\n                return t[o] = r, !n._canNotify || !1 === t.canNotify || (n.observables && !n.observables[o] || n._notify({\n                  eventName: \"change\",\n                  object: n,\n                  target: t,\n                  action: \"update\",\n                  index: e,\n                  path: e + \".\" + o,\n                  oldValue: i,\n                  newValue: r,\n                  propertyName: o\n                }), !0);\n              }\n            });\n          }\n\n          getItem(e) {\n            return this._array[e];\n          }\n\n          setItem(e, t) {\n            const n = this,\n                  o = n._array[e];\n            n._array[e] = n._getItem(e, t), n._notify({\n              eventName: \"change\",\n              object: n._array,\n              action: \"update\",\n              index: e,\n              removed: [o],\n              addedCount: 1\n            });\n          }\n\n          get length() {\n            return this._array.length;\n          }\n\n          set length(e) {\n            const t = this;\n            r.isNumber(e) && t._array && t._array.length !== e && t.splice(e, t._array.length - e);\n          }\n\n          toString() {\n            return this._array.toString();\n          }\n\n          toLocaleString() {\n            return this._array.toLocaleString();\n          }\n\n          concat() {\n            const e = this;\n            e._addArgs.index = e._array.length;\n\n            const t = e._array.concat.apply(e._array, arguments);\n\n            return new Smart.ObservableArray(t);\n          }\n\n          join(e) {\n            return this._array.join(e);\n          }\n\n          pop() {\n            const e = this;\n            e._removeArgs.index = e._array.length - 1, delete e[e._array.length - 1];\n\n            const t = e._array.pop();\n\n            return e._removeArgs.removed = [t], e._notify(e._removeArgs), e._notifyLengthChange(), t;\n          }\n\n          push() {\n            const e = this;\n\n            if (e._addArgs.index = e._array.length, 1 === arguments.length && Array.isArray(arguments[0])) {\n              const t = arguments[0];\n\n              for (let n = 0, o = t.length; n < o; n++) {\n                const o = e._getItem(e._array.length, t[n]);\n\n                e._array.push(o);\n              }\n            } else {\n              const t = e._getItem(e._addArgs.index, arguments[0]);\n\n              e._array.push.apply(e._array, [t]);\n            }\n\n            return e._addArgs.addedCount = e._array.length - e._addArgs.index, e._notify(e._addArgs), e._notifyLengthChange(), e._array.length;\n          }\n\n          _notifyLengthChange() {\n            const e = this;\n            if (!e.canNotify) return;\n\n            const t = e._createPropertyChangeData(\"length\", e._array.length);\n\n            e._notify(t);\n          }\n\n          _createPropertyChangeData(e, t, n) {\n            return {\n              eventName: \"change\",\n              object: this,\n              action: e,\n              value: t,\n              oldValue: n\n            };\n          }\n\n          reverse() {\n            return this._array.reverse();\n          }\n\n          shift() {\n            const e = this,\n                  t = e._array.shift();\n\n            return e._removeArgs.index = 0, e._removeArgs.removed = [t], e._notify(e._removeArgs), e._notifyLengthChange(), t;\n          }\n\n          slice(e, t) {\n            return this._array.slice(e, t);\n          }\n\n          sort(e) {\n            return this._array.sort(e);\n          }\n\n          splice(e, t, n) {\n            const o = this,\n                  r = o._array.length;\n            let i;\n            if (n && n.length) for (let r = 0; r < n.length; r++) i = o._array.splice(e + r, t, n[r]);else i = o._array.splice.apply(o._array, arguments);\n\n            if (n) {\n              let t = o.canNotify;\n              if (o.canNotify = !1, n.length) for (let t = 0; t < n.length; t++) o.setItem(e + t, n[t]);else o.setItem(e, n);\n              o.canNotify = t, o._notify({\n                eventName: \"change\",\n                object: this,\n                action: \"add\",\n                index: e,\n                added: i,\n                addedCount: o._array.length > r ? o._array.length - r : 0\n              });\n            } else o._notify({\n              eventName: \"change\",\n              object: this,\n              action: \"remove\",\n              index: e,\n              removed: i,\n              addedCount: o._array.length > r ? o._array.length - r : 0\n            });\n\n            return o._array.length !== r && o._notifyLengthChange(), i;\n          }\n\n          unshift() {\n            const e = this,\n                  t = e._array.length,\n                  n = e._array.unshift.apply(e._array, arguments);\n\n            return e._addArgs.index = 0, e._addArgs.addedCount = n - t, e._notify(this._addArgs), e._notifyLengthChange(), n;\n          }\n\n          indexOf(e, t) {\n            const n = this;\n\n            for (let o = t || 0, r = n._array.length; o < r; o++) if (n._array[o] === e) return o;\n\n            return -1;\n          }\n\n          lastIndexOf(e, t) {\n            const n = this;\n\n            for (let o = t || n._array.length - 1; o >= 0; o--) if (n._array[o] === e) return o;\n\n            return -1;\n          }\n\n          find(e, t) {\n            return this._array.find(e, t);\n          }\n\n          findIndex(e, t) {\n            return this._array.findIndex(e, t);\n          }\n\n          every(e, t) {\n            return this._array.every(e, t);\n          }\n\n          some(e, t) {\n            return this._array.some(e, t);\n          }\n\n          forEach(e, t) {\n            this._array.forEach(e, t);\n          }\n\n          map(e, t) {\n            return this._array.map(e, t);\n          }\n\n          filter(e, t) {\n            return this._array.filter(e, t);\n          }\n\n          reduce(e, t) {\n            return void 0 !== t ? this._array.reduce(e, t) : this._array.reduce(e);\n          }\n\n          reduceRight(e, t) {\n            return void 0 !== t ? this._array.reduceRight(e, t) : this._array.reduceRight(e);\n          }\n\n          move(e, t) {\n            this.splice(t, 0, this.splice(e, 1)[0]);\n          }\n\n        }\n\n        let T = {};\n        window[n] && (T = window[n]), window[n] = function (e, t) {\n          let o = e;\n\n          if (e) {\n            if (e.indexOf(\"#\") >= 0 || e.indexOf(\".\") >= 0) return u[e] ? u[e] : t ? (u[e] = new t(), function (e, t) {\n              const n = t.properties;\n              t._properties = [];\n\n              const o = function (n, r) {\n                const i = Object.keys(n);\n\n                for (let s = 0; s < i.length; s++) {\n                  const a = i[s],\n                        l = n[a];\n                  t._properties[r + a] = l, Array.isArray(l) ? t._properties[r + a] = new L(l, function (t) {\n                    const n = a + \".\" + t.path,\n                          o = t.newValue,\n                          r = document.querySelector(e);\n\n                    if (r) {\n                      const e = n.split(\".\");\n                      let t = r;\n\n                      for (let n = 0; n < e.length; n++) t = t[e[n]];\n\n                      t = o;\n                    }\n                  }) : (Object.defineProperty(n, a, {\n                    configurable: !1,\n                    enumerable: !0,\n                    get: () => t._properties[r + a],\n\n                    set(e) {\n                      t._properties[r + a] = e;\n                    }\n\n                  }), l && \"DataAdapter\" === l.constructor.name || l && \"object\" == typeof l && Smart.DataAdapter && l instanceof Smart.DataAdapter || \"object\" == typeof l && l && Object.keys(l).length > 0 && o(l, r + a + \".\"));\n                }\n              };\n\n              o(n, \"\"), Object.defineProperty(t, \"properties\", {\n                configurable: !1,\n                enumerable: !0,\n                get: () => n\n              });\n              const r = document.querySelector(e);\n              if (r && r.isReady) for (let e in n) r[e] = n[e];else if (r) {\n                r.props = {};\n\n                for (let e in n) r.props[e] = n[e];\n              }\n            }(e, u[e]), u[e]) : void 0;\n\n            if (t) {\n              if (P.tagNames[e] = t, P.lazyRegister) {\n                P.toRegister || (P.toRegister = []);\n                const e = a.toCamelCase(o).replace(/[a-z]+/, \"\");\n                return window[n][e] = t, void P.toRegister.push({\n                  tagName: o,\n                  element: t\n                });\n              }\n\n              P.register(o, t);\n            }\n          }\n        }, window.addEventListener(\"load\", function () {\n          const e = window[n].Elements.tagNames;\n          let t = [];\n\n          for (let o in e) {\n            const r = e[o];\n            let i = document.querySelectorAll(\"[\" + o + \"]\");\n\n            for (let e = 0; e < i.length; e++) {\n              const t = i[e];\n              t instanceof HTMLDivElement && (t.__proto__ = r.prototype, t.created(), t.connectedCallback()), t.classList.add(\"smart-element-ready\");\n            }\n\n            let s = r.name;\n            \"Item\" === s && (s = \"ListItem\"), i = document.querySelectorAll('[is=\"' + n.toLocaleLowerCase() + s + '\"]');\n\n            for (let e = 0; e < i.length; e++) t.push(i[e]);\n          }\n\n          if (t.length > 0) {\n            const e = e => {\n              let t = [],\n                  n = e.parentNode;\n\n              for (; n && 9 !== n.nodeType;) n instanceof HTMLElement == 1 && t.push(n), n = n.parentNode;\n\n              return t;\n            };\n\n            t.sort(function (t, n) {\n              let o = e(t).length,\n                  r = e(n).length;\n              return o < r ? 1 : o > r ? -1 : 0;\n            });\n\n            for (let e = 0; e < t.length; e++) {\n              const n = t[e],\n                    o = n.getAttribute(\"is\");\n              let r;\n              r = \"smartItem\" === o ? new window.smartListItem(n) : new window[o](n), r.removeAttribute(\"is\");\n            }\n          }\n        });\n\n        const D = function () {\n          if (\"complete\" === document.readyState && \"manual\" !== window[n].RenderMode) {\n            x.sort(function (e, t) {\n              let n = e.element.parents.length,\n                  o = t.element.parents.length;\n              return n < o ? -1 : n > o ? 1 : 0;\n            });\n\n            for (let e = 0; e < x.length; e++) window[n].RenderMode = \"\", x[e].element.isLoading = !1, x[e].callback(), window[n].RenderMode = \"\";\n\n            x = [], document.removeEventListener(\"readystatechange\", D);\n          }\n        };\n\n        Object.assign(window[n], {\n          Elements: P,\n          Modules: [],\n          BaseElement: class extends C {\n            static get observedAttributes() {\n              let e = this,\n                  t = [\"external-style\"];\n\n              for (let n in e.prototype.extendedProperties) {\n                const o = e.prototype.extendedProperties[n];\n                t.push(o.attributeName);\n              }\n\n              return t;\n            }\n\n            static get styleUrls() {\n              return [];\n            }\n\n            static get styles() {\n              return \"\";\n            }\n\n            get styleUrl() {\n              return this._styleUrl;\n            }\n\n            set styleUrl(e) {\n              this._styleUrl = e;\n            }\n\n            get isInShadowDOM() {\n              const e = this,\n                    t = e.getRootNode();\n              return !e.hasAttribute(\"smart-blazor\") && t !== document && t !== e;\n            }\n\n            getShadowRootOrBody() {\n              const e = this;\n              return e.isInShadowDOM ? e.getRootNode().host.shadowRoot : document.body;\n            }\n\n            get enableShadowDOM() {\n              return window[n].EnableShadowDOM;\n            }\n\n            importStyle(e, t) {\n              this._importStyle(e, t);\n            }\n\n            _importStyle(e, t) {\n              const n = this;\n              if (!n.shadowRoot || !e) return;\n\n              const o = e => {\n                const o = n.shadowRoot.children;\n\n                for (let n = 0; n < o.length; n++) {\n                  const r = o[n];\n                  if (r instanceof HTMLLinkElement && r.href === e) return t && t(), null;\n                }\n\n                const r = document.createElement(\"link\");\n                return r.rel = \"stylesheet\", r.type = \"text/css\", r.href = e, r.onload = t, r;\n              },\n                    r = (() => {\n                const e = n.shadowRoot.children;\n                let t = null;\n\n                for (let n = 0; n < e.length; n++) {\n                  const o = e[n];\n                  o instanceof HTMLLinkElement && (t = o);\n                }\n\n                return t;\n              })(),\n                    i = (e, t) => {\n                t.parentNode.insertBefore(e, t.nextSibling);\n              };\n\n              if (Array.isArray(e)) {\n                const t = document.createDocumentFragment();\n\n                for (let n = 0; n < e.length; n++) {\n                  const r = o(e[n]);\n                  r && t.appendChild(r);\n                }\n\n                r ? i(t, r) : n.shadowRoot.insertBefore(t, n.shadowRoot.firstChild);\n              } else {\n                const t = o(e);\n                if (!t) return;\n                r ? i(t, r) : n.shadowRoot.insertBefore(t, n.shadowRoot.firstChild);\n              }\n            }\n\n            attributeChanged(e, t, n) {\n              \"style-url\" === e && (this.styleUrl = n);\n            }\n\n            attributeChangedCallback(e, t, n) {\n              this.isReady && super.attributeChangedCallback(e, t, n);\n            }\n\n            constructor(e, t) {\n              super();\n              const n = this;\n\n              if (e) {\n                t && (n._initProperties = t);\n\n                const o = e => {\n                  if (\"string\" == typeof e ? document.querySelector(e) : e) {\n                    const o = \"string\" == typeof e ? document.querySelector(e) : e;\n\n                    if (o instanceof HTMLDivElement) {\n                      const r = document.createElement(n.tagName);\n\n                      for (let e of o.attributes) r.setAttribute(e.name, o.getAttribute(e.name));\n\n                      for (; o.childNodes.length;) r.appendChild(o.firstChild);\n\n                      return \"string\" == typeof e && (r.id = e.substring(1)), r._initProperties = t, o.parentNode && o.parentNode.replaceChild(r, o), r;\n                    }\n\n                    if (t) {\n                      const e = o.context;\n\n                      if (o._initProperties = t, o.isReady) {\n                        o.context = o;\n                        const n = {},\n                              r = {};\n\n                        for (let e in t) n[e] = o[e], r[e] = t[e];\n\n                        Object.getOwnPropertyNames(t).length > 0 && (o.initProperties(), o.propertyChangedHandler(t, n, r)), o.context = e;\n                      }\n                    }\n\n                    return o;\n                  }\n                };\n\n                if (\"string\" == typeof e) {\n                  const t = document.querySelectorAll(e),\n                        n = [];\n\n                  if (t.length > 1) {\n                    for (let e = 0; e < t.length; e++) {\n                      const r = o(t[e]);\n                      n.push(r);\n                    }\n\n                    return n;\n                  }\n                } else if (e && e.length > 0) {\n                  const t = e;\n\n                  if (t.length > 1) {\n                    for (let e = 0; e < t.length; e++) {\n                      const n = o(t[e]);\n\n                      _.push(n);\n                    }\n\n                    return _;\n                  }\n                }\n\n                return o(e);\n              }\n\n              n._styleUrl = \"\", n.isUtilityElement || n.created();\n            }\n\n            _getRootShadowParent() {\n              let e = this.shadowParent;\n\n              for (; e;) {\n                if (!e.shadowParent) return e;\n                e = e.shadowParent;\n              }\n\n              return e || this.shadowParent;\n            }\n\n            _getStyleUrl(e) {\n              let t = y.Core.getScriptLocation() + window[n].StyleBaseUrl + e;\n              return this.shadowParent && (t = t.replace(\"scoped/\", \"\")), t;\n            }\n\n            _getStyleUrls() {\n              const e = this;\n              e.nodeName.startsWith(n);\n              const t = e.getStaticMember(\"styleUrls\", \"array\"),\n                    o = [];\n\n              for (let n = 0; n < t.length; n++) {\n                const r = t[n],\n                      i = e._getStyleUrl(r);\n\n                o.push(i);\n              }\n\n              return o;\n            }\n\n            _setupShadowRoot() {\n              const e = this;\n              e.classList.add(\"smart-element-init\");\n\n              const t = t => {\n                t.$.root && (t.$.root.classList.add(n.toLowerCase() + \"-element\"), t.$.root.classList.add(e.nodeName.toLowerCase())), t.setup(), t.classList.remove(\"smart-element-init\");\n              };\n\n              if (document.adoptedStyleSheets) if (window[n].AdoptedStyleSheets) window[n].AdoptedStyleSheetsLoaded ? (e.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets, t(e)) : (e.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets, window[n].AdoptedStyleSheetsLoadedQueue || (window[n].AdoptedStyleSheetsLoadedQueue = []), window[n].AdoptedStyleSheetsLoadedQueue.push(e));else {\n                const o = new CSSStyleSheet();\n                let r = y.Core.getScriptLocation() + \"/styles/smart.default.css\";\n                o.replace('@import url(\"' + r + '\")').then(() => {\n                  if (t(e), window[n].AdoptedStyleSheetsLoaded = !0, window[n].AdoptedStyleSheetsLoadedQueue) {\n                    const e = window[n].AdoptedStyleSheetsLoadedQueue;\n\n                    for (let n = 0; n < e.length; n++) {\n                      const o = e[n];\n                      t(o);\n                    }\n\n                    delete window[n].AdoptedStyleSheetsLoadedQueue;\n                  }\n                }).catch(e => {\n                  console.error(\"Failed to load:\", e);\n                }), window[n].AdoptedStyleSheets = [o], document.adoptedStyleSheets = [o], e.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets;\n              }\n            }\n\n            connect() {\n              const e = this;\n              window[n].EnableShadowDOM && !e.shadowRoot && !0 !== e.isInShadowDOM && (e.attachShadow({\n                mode: \"open\"\n              }), e.shadowRoot && e.$.root && (e.shadowRoot.appendChild(e.$.root), e.$.root.classList.add(e.nodeName.toLowerCase()))), e.shadowRoot || e.shadowParent ? e.shadowRoot ? e._setupShadowRoot() : (e.shadowParent && window[n].EnableShadowDOM, e.setup()) : e.setup();\n            }\n\n            connectedCallback() {\n              const e = this;\n              if (e.isLoading || e.isUtilityElement) return;\n              e.classList.add(\"smart-element-init\");\n\n              const t = function () {\n                e.classList.remove(\"smart-element-init\");\n              };\n\n              if (\"complete\" === document.readyState && (void 0 === window[n].isAngular && (window[n].isAngular = null !== document.body.querySelector(\"[ng-version]\")), window[n].isAngular)) for (let t = 0; t < e.parents.length && !e.parents[t].nodeName.toLowerCase().startsWith(n.toLowerCase() + \"-\"); t++) if (e.parents[t].hasAttribute(\"ng-version\") && !e.classList.contains(\"smart-angular\")) {\n                window[n].RenderMode = \"manual\";\n                break;\n              }\n\n              if (\"complete\" === document.readyState && \"manual\" !== window[n].RenderMode) {\n                const n = e.parents;\n                n.length && \"HTML\" === n[n.length - 1].nodeName || e.getRootNode().host ? (e.checkIsInDomTimer && clearInterval(e.checkIsInDomTimer), t(), e.connect()) : (e.checkIsInDomTimer && clearInterval(e.checkIsInDomTimer), n.length > 0 && (e.checkIsInDomTimer = setInterval(() => {\n                  const n = e.parents;\n                  0 === n.length && clearInterval(e.checkIsInDomTimer), n.length > 0 && \"HTML\" === n[n.length - 1].nodeName && (clearInterval(e.checkIsInDomTimer), t(), e.connect());\n                }, 100)));\n              } else e.isLoading = !0, x.push({\n                element: this,\n                callback: function () {\n                  this.isReady || (t(), this.connect());\n                }.bind(e)\n              });\n            }\n\n            disconnectedCallback() {\n              const e = this;\n              e.isAttached ? (e.shadowParent = null, e.detached()) : e._resetShadowParent();\n            }\n\n            adoptedCallback() {\n              this.setup();\n            }\n\n            appendTemplate(e) {\n              const t = this;\n              t.shadowRoot ? t.shadowRoot.appendChild(e) : t.appendChild(e);\n            }\n\n            _resetShadowParent() {\n              const e = this;\n              if (!window[n].EnableShadowDOM || null === e.shadowParent) return;\n              const t = [];\n              let o = e.parentNode;\n\n              for (; o && 9 !== o.nodeType;) {\n                if (o instanceof HTMLElement == 1) t.push(o);else if (11 === o.nodeType && o.host) {\n                  o = o.host;\n                  continue;\n                }\n                o = o.parentNode;\n              }\n\n              for (let n = 0; n < t.length; n++) if (t[n] === e.shadowParent) return;\n\n              t.length > 0 && \"HTML\" === t[t.length - 1].nodeName && (e.shadowParent = null);\n            }\n\n          },\n          Utilities: y,\n          Import: function (e, t) {\n            let n = 0;\n\n            const o = function (e, t) {\n              return new Promise(n => {\n                const o = document.createElement(\"script\");\n                o.src = e, o.onload = n;\n\n                for (let e = 0; e < document.head.children.length; e++) {\n                  const o = document.head.children[e];\n                  if (o.src && o.src.toString().indexOf(t) >= 0) return void n();\n                }\n\n                document.head.appendChild(o);\n              });\n            };\n\n            return new Promise(r => {\n              const i = y.Core.getScriptLocation(),\n                    s = function (t) {\n                if (!e[t]) return;\n                const a = i + \"/\" + e[t];\n                o(a, e[t]).then(function () {\n                  n++, n === e.length && r(), s(t + 1);\n                });\n              };\n\n              if (t) for (let t = 0; t < e.length; t++) {\n                const s = i + \"/\" + e[t];\n                o(s, e[t]).then(function () {\n                  n++, n === e.length && r();\n                });\n              } else s(0);\n            });\n          },\n          ObservableArray: L,\n          Observable: class {\n            constructor(e, t) {\n              const n = this;\n              var o;\n              return this.name = \"observable\", e && Object.assign(n, e), o = e, Object.getOwnPropertyNames(Object.getPrototypeOf(o)).forEach(e => \"constructor\" === e || !!e.startsWith(\"_\") || void (n[e] = o[e])), new Proxy(n, {\n                deleteProperty: function (e, t) {\n                  return delete e[t], !0;\n                },\n                get: function (e, t) {\n                  return e[t];\n                },\n                set: function (e, o, r) {\n                  const i = e[o];\n                  return i === r || (e[o] = r, !(\"notifyFn\" !== o && !o.startsWith(\"_\") && \"canNotify\" !== o && (!t || -1 !== t.indexOf(o)) && n.canNotify && (n._notify({\n                    target: e,\n                    propertyName: o,\n                    oldValue: i,\n                    newValue: r\n                  }), 0)));\n                }\n              });\n            }\n\n            get canNotify() {\n              const e = this;\n              return void 0 === e._canNotify && (e._canNotify = !0), e._canNotify;\n            }\n\n            set canNotify(e) {\n              this._canNotify = e;\n            }\n\n            _notify(e) {\n              const t = this;\n              if (t.canNotify && t.notifyFn) for (let n = 0; n < t.notifyFn.length; n++) t.notifyFn[n](e);\n            }\n\n            notify(e) {\n              const t = this;\n              e && (t.notifyFn || (t.notifyFn = []), t.notifyFn.push(e));\n            }\n\n          },\n          Component: class {\n            constructor(e, t) {\n              const n = this.name;\n              let o = null;\n              return e ? o = new window[n](e, t) : (o = new window[n](), o._initProperties = t), this._element = o, o;\n            }\n\n            get name() {\n              return \"Component\";\n            }\n\n            get element() {\n              return this._element;\n            }\n\n          },\n          Theme: T.Theme || \"\",\n          EnableShadowDOM: T.ShadowDom || !1,\n          BaseUrl: \"./\",\n          StyleBaseUrl: \"/styles/default/\",\n          Version: e,\n          Templates: t,\n          RenderMode: T.RenderMode || \"auto\",\n          Render: function () {\n            const e = () => {\n              window[n].RenderMode = \"\", D();\n            };\n\n            \"complete\" === document.readyState ? e() : (window.removeEventListener(\"load\", e), window.addEventListener(\"load\", e));\n          },\n          Data: u,\n          Mode: T.Mode || \"production\",\n          License: \"Evaluation\"\n        });\n        let O = window[n].Theme;\n        \"manual\" !== window[n].RenderMode && document.addEventListener(\"readystatechange\", D), Object.defineProperty(window[n], \"Theme\", {\n          configurable: !1,\n          enumerable: !0,\n          get: () => O,\n\n          set(e) {\n            const t = O;\n            O = e, w.fireEvent(\"theme-changed\", {\n              oldValue: t,\n              newValue: e\n            }, {\n              bubbles: !0,\n              cancelable: !0\n            });\n          }\n\n        }), window[n](\"smart-base-element\", window[n].BaseElement), window[n](\"smart-content-element\", class extends window[n].BaseElement {\n          static get properties() {\n            return {\n              content: {\n                type: \"any\",\n                reflectToAttribute: !1\n              },\n              innerHTML: {\n                type: \"string\",\n                reflectToAttribute: !1\n              }\n            };\n          }\n\n          template() {\n            return \"<div inner-h-t-m-l='[[innerHTML]]'></div>\";\n          }\n\n          ready() {\n            super.ready(), this.applyContent();\n          }\n\n          refresh() {}\n\n          clearContent() {\n            const e = this;\n\n            for (; e.$.content.firstChild;) e.$.content.removeChild(e.$.content.firstChild);\n          }\n\n          applyContent() {\n            const e = this;\n            if (void 0 === e.content) return void (e.content = e.$.content);\n            if (\"\" === e.content || null === e.content) return void e.clearContent();\n            if (e.content instanceof HTMLElement) return e.clearContent(), void e.$.content.appendChild(e.content);\n            const t = document.createDocumentFragment();\n            let n = document.createElement(\"div\");\n            t.appendChild(n), e.content instanceof HTMLElement ? n.appendChild(e.content) : n.innerHTML = e.content;\n            let o = Array.from(n.childNodes);\n            n.parentNode.removeChild(n);\n\n            for (let e = 0; e < o.length; e++) t.appendChild(o[e]);\n\n            e.clearContent(), e.$.content.appendChild(t);\n          }\n\n          propertyChangedHandler(e, t, n) {\n            super.propertyChangedHandler(e, t, n);\n            const o = this;\n            t !== n && (\"innerHTML\" === e && (o.content = n, o.applyContent(), o.innerHTML = o.content = y.Core.html(o.$.content)), \"content\" === e && o.applyContent());\n          }\n\n        }), window[n](\"smart-scroll-viewer\", class extends window[n].ContentElement {\n          static get properties() {\n            return {\n              horizontalScrollBarVisibility: {\n                type: \"string\",\n                value: \"auto\",\n                allowedValues: [\"auto\", \"disabled\", \"hidden\", \"visible\"]\n              },\n              touchScrollRatio: {\n                type: \"any\",\n                value: null\n              },\n              touchVelocityCoefficient: {\n                type: \"number\",\n                value: 50\n              },\n              verticalScrollBarVisibility: {\n                type: \"string\",\n                value: \"auto\",\n                allowedValues: [\"auto\", \"disabled\", \"hidden\", \"visible\"]\n              }\n            };\n          }\n\n          static get listeners() {\n            return {\n              touchmove: \"_touchmoveHandler\",\n              touchstart: \"_touchstartHandler\",\n              wheel: \"_mouseWheelHandler\",\n              \"document.up\": \"_upHandler\"\n            };\n          }\n\n          static get styleUrls() {\n            return [\"smart.scrollviewer.css\"];\n          }\n\n          template() {\n            return '<div id=\"container\" class=\"smart-container\" role=\"presentation\">\\n                        <div id=\"scrollViewerContainer\" class=\"smart-scroll-viewer-container\" role=\"presentation\">\\n                            <div id=\"scrollViewerContentContainer\" inner-h-t-m-l=\\'[[innerHTML]]\\' class=\"smart-scroll-viewer-content-container\" role=\"presentation\">\\n                                <content></content>\\n                            </div>\\n                        </div>\\n                        <smart-scroll-bar id=\"verticalScrollBar\" theme=\"[[theme]]\"  animation=\"[[animation]]\" disabled=\"[[disabled]]\" right-to-left=\"[[rightToLeft]]\" orientation=\"vertical\"></smart-scroll-bar>\\n                        <smart-scroll-bar id=\"horizontalScrollBar\" theme=\"[[theme]]\" disabled=\"[[disabled]]\" right-to-left=\"[[rightToLeft]]\"></smart-scroll-bar>\\n                    </div>';\n          }\n\n          appendChild(e) {\n            const t = this;\n\n            if (e) {\n              if (!t.isCompleted || e.classList && e.classList.contains(\"smart-resize-trigger-container\")) {\n                const e = Array.prototype.slice.call(arguments, 2);\n                return HTMLElement.prototype.appendChild.apply(t, e.concat(Array.prototype.slice.call(arguments)));\n              }\n\n              t.$.scrollViewerContentContainer.appendChild(e);\n            }\n          }\n\n          removeChild(e) {\n            const t = this;\n\n            if (e) {\n              if (!t.isCompleted || e.classList && e.classList.contains(\"smart-resize-trigger-container\")) {\n                const e = Array.prototype.slice.call(arguments, 2);\n                return HTMLElement.prototype.removeChild.apply(t, e.concat(Array.prototype.slice.call(arguments)));\n              }\n\n              t.$.scrollViewerContentContainer.removeChild(e);\n            }\n          }\n\n          removeAll() {\n            const e = this;\n            e.isCompleted && (e.$.scrollViewerContentContainer.innerHTML = \"\");\n          }\n\n          _horizontalScrollbarHandler(e) {\n            const t = this;\n            t.$.scrollViewerContentContainer.style.left = (t.rightToLeft ? 1 : -1) * t.scrollLeft + \"px\", e.stopPropagation && e.stopPropagation(), t.onHorizontalChange && t.onHorizontalChange(e);\n          }\n\n          _verticalScrollbarHandler(e) {\n            const t = this;\n            t.$.scrollViewerContentContainer.style.top = -t.scrollTop + \"px\", e.stopPropagation && e.stopPropagation(), t.onVerticalChange && t.onVerticalChange(e);\n          }\n\n          _touchmoveHandler(e) {\n            const t = this;\n            if (t._touchmoveInside && e.cancelable) return e.preventDefault(), void e.stopPropagation();\n            const n = t.scrollHeight > 0,\n                  o = t.scrollWidth > 0,\n                  r = t._touchCoords;\n            if (!n && !o || !r) return;\n            const i = e.touches[0];\n            let s, a, l, d;\n            t._touchCoords = [i.pageX, i.pageY], n ? (s = t.scrollTop, a = t.scrollHeight, l = i.pageY, d = r[1]) : (s = t.scrollLeft, a = t.scrollWidth, l = i.pageX, d = r[0]);\n            const c = parseFloat(l.toFixed(5)),\n                  u = parseFloat(d.toFixed(5));\n            0 === s && c >= u || s === a && c <= u || (l !== d && (t._touchmoveInside = !0), e.cancelable && (e.preventDefault(), e.stopPropagation()));\n          }\n\n          _touchstartHandler(e) {\n            const t = e.touches[0];\n            this._touchCoords = [t.pageX, t.pageY];\n          }\n\n          _mouseWheelHandler(e) {\n            const t = this;\n\n            if (!t.disabled && (t.computedHorizontalScrollBarVisibility || t.computedVerticalScrollBarVisibility)) {\n              if (e.shiftKey && t.computedHorizontalScrollBarVisibility) {\n                const n = t.scrollLeft;\n                if (0 === n && e.deltaX < 0 || n === t.scrollHeight && e.deltaX > 0) return;\n                return e.stopPropagation(), e.preventDefault(), void (t.scrollWidth > 0 && t.scrollTo(void 0, t.scrollLeft + t._getScrollCoefficient(e, t.offsetWidth)));\n              }\n\n              if (t.computedVerticalScrollBarVisibility) {\n                const n = t.scrollTop;\n                if (0 === n && e.deltaY < 0 || n === t.scrollHeight && e.deltaY > 0) return;\n                e.stopPropagation(), e.preventDefault(), t.scrollHeight > 0 && t.scrollTo(t.scrollTop + t._getScrollCoefficient(e, t.offsetHeight));\n              }\n            }\n          }\n\n          _overriddenHandler() {}\n\n          _upHandler() {\n            delete this._touchCoords, delete this._touchmoveInside;\n          }\n\n          _getScrollCoefficient(e, t) {\n            const n = e.deltaMode,\n                  o = Math.abs(e.deltaY);\n            let r;\n            return 0 === n ? r = o < 100 / 3 ? o : t : 1 === n ? r = o < 1 ? o * (100 / 3) : t : 2 === n && (r = t), e.deltaY < 0 ? -r : r;\n          }\n\n          applyContent() {\n            super.applyContent(), this.refresh();\n          }\n\n          get computedHorizontalScrollBarVisibility() {\n            const e = this;\n            return e._scrollView && e._scrollView.hScrollBar ? !e._scrollView.hScrollBar.$.hasClass(\"smart-hidden\") : null;\n          }\n\n          get computedVerticalScrollBarVisibility() {\n            const e = this;\n            return e._scrollView && e._scrollView.vScrollBar ? !e._scrollView.vScrollBar.$.hasClass(\"smart-hidden\") : null;\n          }\n\n          scrollTo(e, t) {\n            const n = this;\n            n._scrollView && (void 0 !== e && n._scrollView.scrollTo(e), void 0 !== t && n._scrollView.scrollTo(t, !1));\n          }\n\n          refreshScrollBarsVisibility() {\n            const e = this;\n            e._scrollView && (e._scrollView.hScrollBar.disabled = e.disabled, e._scrollView.vScrollBar.disabled = e.disabled, \"disabled\" === e.horizontalScrollBarVisibility && (e._scrollView.hScrollBar.disabled = !0), \"disabled\" === e.verticalScrollBarVisibility && (e._scrollView.vScrollBar.disabled = !0), e.scrollWidth > 0 ? e._scrollView.hScrollBar.$.removeClass(\"smart-hidden\") : \"visible\" !== e.horizontalScrollBarVisibility && e._scrollView.hScrollBar.$.addClass(\"smart-hidden\"), e.scrollHeight > 0 ? e._scrollView.vScrollBar.$.removeClass(\"smart-hidden\") : \"visible\" !== e.verticalScrollBarVisibility && e._scrollView.vScrollBar.$.addClass(\"smart-hidden\"), \"hidden\" === e.horizontalScrollBarVisibility && e._scrollView.hScrollBar.$.addClass(\"smart-hidden\"), \"hidden\" === e.verticalScrollBarVisibility && e._scrollView.vScrollBar.$.addClass(\"smart-hidden\"), \"visible\" === e.horizontalScrollBarVisibility && e._scrollView.hScrollBar.$.removeClass(\"smart-hidden\"), \"visible\" === e.verticalScrollBarVisibility && (e._scrollView.vScrollBar.$.removeClass(\"smart-hidden\"), e.disabled || (e._scrollView.vScrollBar.disabled = e.scrollHeight <= 0)), e.computedHorizontalScrollBarVisibility && e.computedVerticalScrollBarVisibility ? (e._scrollView.hScrollBar.$.addClass(\"bottom-corner\"), e._scrollView.vScrollBar.$.addClass(\"bottom-corner\")) : (e._scrollView.hScrollBar.$.removeClass(\"bottom-corner\"), e._scrollView.vScrollBar.$.removeClass(\"bottom-corner\")));\n          }\n\n          ready() {\n            super.ready();\n            const e = this;\n            e.$.verticalScrollBar.onChange = t => {\n              t.detail = t, e._verticalScrollbarHandler(t);\n            }, e.$.horizontalScrollBar.onChange = t => {\n              t.detail = t, e._horizontalScrollbarHandler(t);\n            }, e.$.verticalScrollBar.setAttribute(\"aria-controls\", e.id), e.$.horizontalScrollBar.setAttribute(\"aria-controls\", e.id), e._customScrollView || (e._scrollView = new Smart.Utilities.Scroll(e, e.$.horizontalScrollBar, e.$.verticalScrollBar)), e.refresh();\n          }\n\n          refresh() {\n            const e = this;\n\n            function t() {\n              const t = e.$.scrollViewerContainer.classList.contains(\"vscroll\");\n              e.$.scrollViewerContainer.classList.remove(\"vscroll\");\n              const n = e.$.scrollViewerContentContainer.offsetWidth - e.$.scrollViewerContainer.offsetWidth;\n              return n > 0 && \"hidden\" !== e.horizontalScrollBarVisibility || \"visible\" === e.horizontalScrollBarVisibility ? e.$.scrollViewerContainer.classList.add(\"hscroll\") : e.$.scrollViewerContainer.classList.remove(\"hscroll\"), t && e.$.scrollViewerContainer.classList.add(\"vscroll\"), n;\n            }\n\n            function n() {\n              let t;\n              const n = e.$.scrollViewerContainer.classList.contains(\"hscroll\");\n\n              if (e.$.scrollViewerContainer.classList.remove(\"hscroll\"), Smart.Utilities.Core.Browser.Safari) {\n                const n = e.$.scrollViewerContentContainer.getBoundingClientRect().height,\n                      o = e.$.scrollViewerContainer.getBoundingClientRect().height;\n                t = n && o ? parseInt(n) - parseInt(o) : e.$.scrollViewerContentContainer.offsetHeight - e.$.scrollViewerContainer.offsetHeight;\n              } else t = e.$.scrollViewerContentContainer.offsetHeight - e.$.scrollViewerContainer.offsetHeight;\n\n              return t > 0 && \"hidden\" !== e.verticalScrollBarVisibility || \"visible\" === e.verticalScrollBarVisibility ? e.$.scrollViewerContainer.classList.add(\"vscroll\") : e.$.scrollViewerContainer.classList.remove(\"vscroll\"), n && e.$.scrollViewerContainer.classList.add(\"hscroll\"), t;\n            }\n\n            if (!e.$.scrollViewerContentContainer) return;\n            let o = e.scrollWidth,\n                r = e.scrollHeight;\n            e.scrollWidth = t(), e.scrollHeight = n(), e.scrollHeight && r === e.scrollHeight || (e.scrollWidth = t()), e.scrollWidth && o === e.scrollWidth || (e.scrollHeight = n()), e.computedVerticalScrollBarVisibility && (e.scrollHeight += e._scrollView.hScrollBar.offsetHeight), e.computedHorizontalScrollBarVisibility && (e.scrollWidth += e._scrollView.vScrollBar.offsetWidth), 0 === e.scrollHeight && e.scrollWidth > 0 && e.$.container.offsetHeight - e.$.content.offsetHeight < 5 && (e.$.container.style.paddingBottom = e._scrollView.hScrollBar.offsetHeight + \"px\");\n          }\n\n          attached() {\n            const e = this;\n            super.attached(), e._scrollView || e._customScrollView || (e._scrollView = new Smart.Utilities.Scroll(e, e.$.horizontalScrollBar, e.$.verticalScrollBar));\n          }\n\n          detached() {\n            const e = this;\n            super.detached(), e._scrollView && (e._scrollView.unlisten(), delete e._scrollView);\n          }\n\n          get scrollWidth() {\n            const e = this;\n            return e._scrollView && e._scrollView.hScrollBar ? 1 === e._scrollView.hScrollBar.max && \"visible\" === e.horizontalScrollBarVisibility ? 0 : e._scrollView.hScrollBar.max : -1;\n          }\n\n          set scrollWidth(e) {\n            const t = this;\n            e < 0 && (e = 0), t._scrollView && t._scrollView.hScrollBar && (0 === e && \"visible\" === t.horizontalScrollBarVisibility ? t._scrollView.hScrollBar.max = 0 : t._scrollView.hScrollBar.max = e, t.refreshScrollBarsVisibility());\n          }\n\n          get scrollHeight() {\n            const e = this;\n            return e._scrollView && e._scrollView.vScrollBar ? 1 === e._scrollView.vScrollBar.max && \"visible\" === e.verticalScrollBarVisibility ? 0 : e._scrollView.vScrollBar.max : 0;\n          }\n\n          set scrollHeight(e) {\n            const t = this;\n            e < 0 && (e = 0), t._scrollView && t._scrollView.vScrollBar && (0 === e && \"visible\" === t.verticalScrollBarVisibility ? t._scrollView.vScrollBar.max = 1 : t._scrollView.vScrollBar.max = e, t.refreshScrollBarsVisibility());\n          }\n\n          get scrollLeft() {\n            const e = this;\n            return e._scrollView && e._scrollView.hScrollBar ? e._scrollView.hScrollBar.value : 0;\n          }\n\n          set scrollLeft(e) {\n            const t = this;\n            e < 0 && (e = 0), t._scrollView && t._scrollView.hScrollBar && (t._scrollView.hScrollBar.value = e);\n          }\n\n          get scrollTop() {\n            const e = this;\n            return e._scrollView && e._scrollView.vScrollBar ? e._scrollView.vScrollBar.value : 0;\n          }\n\n          set scrollTop(e) {\n            const t = this;\n            e < 0 && (e = 0), t._scrollView && t._scrollView.vScrollBar && (t._scrollView.vScrollBar.value = e);\n          }\n\n          propertyChangedHandler(e, t, n) {\n            const o = this;\n            super.propertyChangedHandler(e, t, n), \"animation\" !== e && \"theme\" !== e && o.refresh();\n          }\n\n        }), window[n].Utilities.Assign(\"PositionDetection\", class {\n          constructor(e, t, n, o) {\n            const r = this;\n\n            if (t) {\n              const n = \"dropDown\" + Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n              t.id = n, e.setAttribute(\"aria-owns\", n);\n            }\n\n            r.context = e, r.dropDown = t, r.defaultParent = n, r.closeMethod = o;\n          }\n\n          handleAutoPositioning() {\n            const e = this,\n                  t = e.context;\n            if (\"auto\" !== t.dropDownPosition || t.disabled || t.isHidden) return;\n            const n = window.requestAnimationFrame;\n            let o,\n                r = Date.now();\n            return o = n(function i() {\n              t.isHidden || document.hidden || (o = n(i), \"auto\" === t.dropDownPosition && !t.disabled && (t.isInShadowDOM ? document.body.contains(t.shadowParent) : document.body.contains(t)) || cancelAnimationFrame(o), t.isHidden && cancelAnimationFrame(o), Date.now() - r >= 200 && (e.scrollHandler(), r = Date.now()));\n            });\n          }\n\n          checkBrowserBounds(e) {\n            const t = this.context;\n            if (\"auto\" === t.dropDownPosition && !t.disabled) switch (e) {\n              case \"vertically\":\n                this.checkBrowserBoundsVertically();\n                break;\n\n              case \"horizontally\":\n                this.checkBrowserBoundsHorizontally();\n                break;\n\n              default:\n                this.checkBrowserBoundsVertically(), this.checkBrowserBoundsHorizontally();\n            }\n          }\n\n          checkBrowserBoundsHorizontally() {\n            const e = this.context,\n                  t = this.dropDown;\n            let n,\n                o = 0;\n            a.isMobile || window.innerWidth === document.documentElement.clientWidth || (o = window.innerWidth - document.documentElement.clientWidth), null !== e._dropDownParent ? n = !0 : t.style.left = \"\";\n            const r = window.innerWidth - o;\n            let i = e.getBoundingClientRect().left;\n\n            if (i < 0 && (t.style.left = (n ? 0 : Math.abs(i)) + \"px\", i = parseFloat(t.style.left)), i + t.offsetWidth > r) {\n              let e = i - Math.abs(r - i - t.offsetWidth);\n              n && (e += window.pageXOffset), t.style.left = (n ? e : e - i) + \"px\", window.innerWidth === document.documentElement.clientWidth && (t.style.left = parseFloat(t.style.left) + o + \"px\"), n && window.innerHeight === document.documentElement.clientHeight && this.positionDropDown(!0);\n            }\n          }\n\n          checkBrowserBoundsVertically(e) {\n            const t = this.context,\n                  n = this.dropDown,\n                  o = t._dropDownListPosition;\n            e || (e = t.getBoundingClientRect()), 0 !== e.height && (document.documentElement.clientHeight - Math.abs(e.top + e.height + n.offsetHeight) >= 0 ? t._dropDownListPosition = \"bottom\" : e.top - n.offsetHeight >= 0 ? t._dropDownListPosition = \"top\" : t._dropDownListPosition = \"overlay-center\", this.updatePositionAttribute(o, t._dropDownListPosition));\n          }\n\n          scrollHandler() {\n            const e = this.context;\n            if (!e.parentElement) return;\n            const t = e.getBoundingClientRect();\n            if (t.top === e._positionTop) return;\n            const n = e._dropDownListPosition;\n            this.checkBrowserBoundsVertically(t), e._dropDownListPosition !== n && this.positionDropDown(), e._positionTop = t.top;\n          }\n\n          getDropDownParent(e) {\n            const t = this.context,\n                  n = this.dropDown;\n            let o = t.dropDownAppendTo;\n            t._positionedParent = null, null === o ? t._dropDownParent = null : \"body\" === o || o === document.body ? t.getRootNode().host ? t._dropDownParent = t.getRootNode().host.shadowRoot : t._dropDownParent = document.body : o instanceof HTMLElement ? t._dropDownParent = o : \"string\" == typeof o ? (o = document.getElementById(o), o instanceof HTMLElement ? t._dropDownParent = o : (t.dropDownAppendTo = null, t._dropDownParent = null)) : (t.dropDownAppendTo = null, t._dropDownParent = null);\n            let r = t._dropDownParent;\n\n            if (null !== r) {\n              for (; r && r instanceof HTMLElement && \"static\" === window.getComputedStyle(r).position && r !== t.getShadowRootOrBody();) r = r.parentElement;\n\n              r === document.body ? t._positionedParent = null : t._positionedParent = r, n && (n.setAttribute(\"animation\", t.animation), \"\" !== t.theme && n.$.addClass(t.theme), e && (t._dropDownParent.appendChild(n), n.$.addClass(\"smart-drop-down-repositioned\")), -1 === t.detachedChildren.indexOf(n) && t.detachedChildren.push(n));\n            }\n          }\n\n          dropDownAppendToChangedHandler() {\n            const e = this.context,\n                  t = this.dropDown,\n                  n = e._dropDownParent;\n            this.getDropDownParent(), e._dropDownParent !== n && (e[this.closeMethod](), [\"left\", \"top\", \"font-size\", \"font-family\", \"font-style\", \"font-weight\"].forEach(e => t.style[e] = null), null === e._dropDownParent ? (this.defaultParent.appendChild(t), t.$.removeClass(\"smart-drop-down-repositioned\")) : (e._dropDownParent.appendChild(t), t.$.addClass(\"smart-drop-down-repositioned\")));\n          }\n\n          dropDownPositionChangedHandler() {\n            const e = this;\n            e.dropDown.style.transition = \"none\", e.context[e.closeMethod](), e.setDropDownPosition(), e.handleAutoPositioning();\n          }\n\n          dropDownAttached(e) {\n            const t = this.context;\n            null !== t._dropDownParent && (t._dropDownParent.appendChild(this.dropDown), this.handleAutoPositioning(), e && t[e]());\n          }\n\n          dropDownDetached() {\n            const e = this.context;\n            null !== e._dropDownParent && document.body.contains(this.dropDown) && document.body.contains(e._dropDownParent) && e._dropDownParent.removeChild(this.dropDown);\n          }\n\n          setDropDownPosition() {\n            const e = this.context,\n                  t = e.dropDownPosition,\n                  n = e._dropDownListPosition;\n            \"auto\" === t ? this.checkBrowserBounds() : e._dropDownListPosition = t, this.updatePositionAttribute(n, e._dropDownListPosition);\n          }\n\n          updatePositionAttribute(e, t) {\n            const n = this.context,\n                  o = this.dropDown;\n            n.$.dropDownButton && !n.$.dropDownButton.hasAttribute(t) && (n.$.dropDownButton.removeAttribute(e), n.$.dropDownButton.setAttribute(t, \"\")), o.hasAttribute(t) || (o.style.transition = \"none\", o.removeAttribute(e), o.setAttribute(t, \"\"), requestAnimationFrame(function () {\n              o.style.transition = null;\n            }));\n          }\n\n          positionDropDown(e) {\n            const t = this.context,\n                  n = this.dropDown;\n            if (!t.opened || null === t._dropDownParent) return;\n            const o = t.getBoundingClientRect();\n            let r, i;\n\n            if (this.customPositionDropDown) {\n              const e = this.customPositionDropDown(o);\n              r = e.left, i = e.top;\n            } else switch (r = o.left, i = o.top, t._dropDownListPosition) {\n              case \"bottom\":\n                i += t.$.container.offsetHeight - 1;\n                break;\n\n              case \"center-bottom\":\n                i += t.$.container.offsetHeight - 1, r += t.offsetWidth - n.offsetWidth / 2;\n                break;\n\n              case \"center-top\":\n                i -= n.offsetHeight - 1, r += t.offsetWidth - n.offsetWidth / 2;\n                break;\n\n              case \"top\":\n                i -= n.offsetHeight - 1;\n                break;\n\n              case \"overlay-bottom\":\n                break;\n\n              case \"overlay-center\":\n                i -= n.offsetHeight / 2 - t.offsetHeight / 2;\n                break;\n\n              case \"overlay-top\":\n                i -= n.offsetHeight - t.offsetHeight;\n            }\n\n            const s = this.getDropDownOffset();\n            n.style.top = i + s.y + \"px\", e || (n.style.left = r + s.x + \"px\");\n          }\n\n          getDropDownOffset() {\n            const e = this.context._positionedParent;\n            let t, n;\n\n            if (e && \"#document-fragment\" !== e.nodeName) {\n              const o = e.getBoundingClientRect();\n              t = -o.left, n = -o.top;\n            } else t = window.pageXOffset, n = window.pageYOffset;\n\n            return {\n              x: t,\n              y: n\n            };\n          }\n\n          placeOverlay() {\n            const e = this.context;\n            if (!e.dropDownOverlay || e._overlay) return;\n            const t = document.createElement(\"div\");\n            t.classList.add(\"smart-drop-down-overlay\"), t.style.width = document.documentElement.scrollWidth + \"px\", t.style.height = document.documentElement.scrollHeight + \"px\", document.body.appendChild(t), e._overlay = t;\n          }\n\n          removeOverlay(e) {\n            const t = this,\n                  n = t.context;\n            n._overlay && (n.hasAnimation && e ? requestAnimationFrame(function e() {\n              t.dropDown.getBoundingClientRect().height > 0 ? requestAnimationFrame(e) : (document.body.removeChild(n._overlay), delete n._overlay);\n            }) : (document.body.removeChild(n._overlay), delete n._overlay));\n          }\n\n        });\n      }();\n      /***/\n    },\n\n    /***/\n    9135:\n    /***/\n    () => {\n      Smart(\"smart-scroll-bar\", class extends Smart.BaseElement {\n        static get properties() {\n          return {\n            clickRepeatDelay: {\n              type: \"integer\",\n              value: 50\n            },\n            largeStep: {\n              type: \"integer\",\n              value: 100\n            },\n            min: {\n              type: \"integer\",\n              value: 0\n            },\n            max: {\n              type: \"integer\",\n              value: 1e3\n            },\n            mechanicalAction: {\n              value: \"switchWhileDragging\",\n              allowedValues: [\"switchUntilReleased\", \"switchWhenReleased\", \"switchWhileDragging\"],\n              type: \"string\"\n            },\n            orientation: {\n              type: \"string\",\n              value: \"horizontal\",\n              allowedValues: [\"horizontal\", \"vertical\"]\n            },\n            step: {\n              type: \"integer\",\n              value: 10\n            },\n            showButtons: {\n              type: \"boolean\",\n              value: !0,\n              defaultReflectToAttribute: !0\n            },\n            value: {\n              type: \"integer\",\n              value: 0\n            }\n          };\n        }\n\n        static get styleUrls() {\n          return [\"smart.scrollbar.css\"];\n        }\n\n        template() {\n          return '<div id=\"container\" class=\"smart-container\" role=\"presentation\">\\n                    <div id=\"nearButton\" class=\"smart-scroll-button smart-arrow-left\" role=\"presentation\" aria-hidden=\"true\"></div>\\n                    <div  id=\"track\" class=\"smart-track\" role=\"presentation\">\\n                        <div id=\"thumb\" class=\"smart-thumb\" role=\"presentation\"></div>\\n                    </div>\\n                    <div id=\"farButton\" class=\"smart-scroll-button smart-arrow-right\" role=\"presentation\" aria-hidden=\"true\"></div>\\n            </div>';\n        }\n\n        static get listeners() {\n          return {\n            \"nearButton.click\": \"_nearButtonClickHandler\",\n            \"nearButton.down\": \"_startRepeat\",\n            \"nearButton.up\": \"_stopRepeat\",\n            \"nearButton.pointerenter\": \"_updateInBoundsFlag\",\n            \"nearButton.pointerleave\": \"_updateInBoundsFlag\",\n            \"farButton.click\": \"_farButtonClickHandler\",\n            \"farButton.down\": \"_startRepeat\",\n            \"farButton.up\": \"_stopRepeat\",\n            \"farButton.pointerenter\": \"_updateInBoundsFlag\",\n            \"farButton.pointerleave\": \"_updateInBoundsFlag\",\n            \"track.down\": \"_trackDownHandler\",\n            \"track.click\": \"_trackClickHandler\",\n            \"track.move\": \"_trackMoveHandler\",\n            \"thumb.down\": \"_dragStartHandler\",\n            \"document.move\": \"_dragHandler\",\n            \"document.up\": \"_dragEndHandler\",\n            up: \"_dragEndHandler\",\n            \"document.selectstart\": \"_selectStartHandler\",\n            resize: \"_resizeHandler\"\n          };\n        }\n\n        _updateInBoundsFlag(t) {\n          const e = this,\n                a = t.target;\n          a._isPointerInBounds = !0, -1 !== t.type.indexOf(\"leave\") && (a._isPointerInBounds = !1), 1 !== (\"buttons\" in t ? t.buttons : t.which) && e._stopRepeat(t);\n        }\n\n        _startRepeat(t) {\n          const e = this;\n          if (e.disabled) return;\n          const a = t.target;\n          a._initialTimer || (a._initialTimer = setTimeout(function () {\n            a._repeatTimer = setInterval(() => {\n              if (a._isPointerInBounds) {\n                const e = \"buttons\" in t ? t.buttons : t.which;\n                a.$.fireEvent(\"click\", {\n                  buttons: e,\n                  clientX: t.clientX,\n                  clientY: t.clientY,\n                  pageX: t.pageX,\n                  pageY: t.pageY,\n                  screenX: t.screenX,\n                  screenY: t.screenY\n                });\n              }\n            }, e.clickRepeatDelay);\n          }, 3 * e.clickRepeatDelay));\n        }\n\n        _stopRepeat(t) {\n          if (this.disabled) return;\n          const e = t.target;\n          e._repeatTimer && (clearInterval(e._repeatTimer), e._repeatTimer = null), e._initialTimer && (clearTimeout(e._initialTimer), e._initialTimer = null);\n        }\n\n        _calculateThumbSize(t) {\n          const e = this,\n                a = e.max - e.min,\n                r = \"horizontal\" === e.orientation ? e.$.track.offsetWidth > 10 : e.$.track.offsetHeight > 10;\n          let n = 0;\n          return a >= 1 && r ? (n = t / (a + t) * t, e.$.thumb.className.indexOf(\"smart-hidden\") >= 0 && e.$thumb.removeClass(\"smart-hidden\")) : e.$thumb.addClass(\"smart-hidden\"), Math.max(10, Math.min(n, t));\n        }\n\n        _dragStartHandler(t) {\n          const e = this;\n          e.disabled || (e.thumbCapture = !0, e.dragStartX = t.clientX, e.dragStartY = t.clientY, e.dragStartValue = e.value, t.stopPropagation(), t.preventDefault());\n        }\n\n        _dragHandler(t) {\n          const e = this;\n          if (!0 !== e.thumbCapture) return;\n          e._isThumbDragged = !0;\n          const a = (e.max - e.min) / (e.scrollBarSize - e.thumbSize),\n                r = \"horizontal\" === e.orientation ? (t.clientX - e.dragStartX) * a : (t.clientY - e.dragStartY) * a;\n          let n = r;\n          e.rightToLeft && \"horizontal\" === e.orientation && (n = -r), e._updateValue(e.dragStartValue + n), t.stopPropagation(), t.preventDefault(), t.originalEvent && (t.originalEvent.stopPropagation(), t.originalEvent.preventDefault());\n        }\n\n        _dragEndHandler(t) {\n          const e = this;\n          e._trackDownTimer && (clearInterval(e._trackDownTimer), e._trackDownTimer = null), e.thumbCapture && (e.thumbCapture = !1, e._isThumbDragged = !1, \"switchWhenReleased\" === e.mechanicalAction ? e._updateValue(e.dragStartValue, e.value) : \"switchUntilReleased\" === this.mechanicalAction && e._updateValue(e.dragStartValue), t.preventDefault(), t.stopPropagation(), t.originalEvent.preventDefault(), t.originalEvent.stopPropagation());\n        }\n\n        _farButtonClickHandler() {\n          const t = this;\n          if (t.disabled) return;\n          const e = t.value;\n          t._updateValue(t.value + (\"horizontal\" === t.orientation && t.rightToLeft ? -1 : 1) * t.step), \"switchUntilReleased\" === t.mechanicalAction && t._updateValue(e);\n        }\n\n        _nearButtonClickHandler() {\n          const t = this;\n          if (t.disabled) return;\n          const e = t.value;\n          t._updateValue(t.value - (\"horizontal\" === t.orientation && t.rightToLeft ? -1 : 1) * t.step), \"switchUntilReleased\" === t.mechanicalAction && t._updateValue(e);\n        }\n\n        propertyChangedHandler(t, e, a) {\n          super.propertyChangedHandler(t, e, a);\n          const r = this;\n\n          switch (t) {\n            case \"min\":\n            case \"max\":\n            case \"orientation\":\n            case \"showButtons\":\n              r._layout(), \"min\" === t ? r.setAttribute(\"aria-valuemin\", a) : \"max\" === t ? r.setAttribute(\"aria-valuemax\", a) : \"orientation\" === t && r.setAttribute(\"aria-orientation\", a);\n              break;\n\n            case \"value\":\n              r._updateValue(e, a);\n\n              break;\n\n            default:\n              r._layout();\n\n          }\n        }\n\n        render() {\n          const t = this;\n          t.setAttribute(\"role\", \"scrollbar\"), t.setAttribute(\"aria-orientation\", t.orientation), t.setAttribute(\"aria-valuemin\", t.min), t.setAttribute(\"aria-valuemax\", t.max), t.setAttribute(\"aria-valuenow\", t.value), t._layout(), super.render();\n        }\n\n        _resizeHandler() {\n          this._layout();\n        }\n\n        refresh() {\n          this._layout();\n        }\n\n        beginUpdate() {\n          this._isUpdating = !0;\n        }\n\n        endUpdate() {\n          this._isUpdating = !1, this.refreshValue();\n        }\n\n        refreshValue() {\n          const t = this;\n          t._layout(), t._updateValue(t.value);\n        }\n\n        _layout() {\n          const t = this;\n          t._isUpdating || (t.scrollBarSize = \"horizontal\" === t.orientation ? t.$.track.offsetWidth : t.$.track.offsetHeight, t.thumbSize = t._calculateThumbSize(t.scrollBarSize), \"horizontal\" === t.orientation && t.$.thumb.style.width !== t.thumbSize + \"px\" ? t.$.thumb.style.width = t.thumbSize + \"px\" : \"vertical\" === t.orientation && t.$.thumb.style.height !== t.thumbSize + \"px\" && (t.$.thumb.style.height = t.thumbSize + \"px\"), \"horizontal\" === t.orientation ? (t.$.nearButton.classList.contains(\"smart-arrow-up\") && t.$.nearButton.classList.remove(\"smart-arrow-up\"), t.$.farButton.classList.contains(\"smart-arrow-down\") && t.$.farButton.classList.remove(\"smart-arrow-down\"), t.$.nearButton.classList.contains(\"smart-arrow-left\") || t.$.nearButton.classList.add(\"smart-arrow-left\"), t.$.farButton.classList.contains(\"smart-arrow-right\") || t.$.farButton.classList.add(\"smart-arrow-right\")) : (t.$.nearButton.classList.contains(\"smart-arrow-left\") && t.$.nearButton.classList.remove(\"smart-arrow-left\"), t.$.farButton.classList.contains(\"smart-arrow-right\") && t.$.farButton.classList.remove(\"smart-arrow-right\"), t.$.nearButton.classList.contains(\"smart-arrow-up\") || t.$.nearButton.classList.add(\"smart-arrow-up\"), t.$.farButton.classList.contains(\"smart-arrow-down\") || t.$.farButton.classList.add(\"smart-arrow-down\")), t._updateThumbPosition(), (t.value > t.max || t.value < t.min) && t._updateValue(t.value, t.value > t.max ? t.max : t.min));\n        }\n\n        _selectStartHandler(t) {\n          this.thumbCapture && t.preventDefault();\n        }\n\n        _trackDownHandler(t) {\n          const e = this;\n          t.target === e.$.track && (e._trackDownTimer && clearInterval(e._trackDownTimer), e.thumbCapture || (e._trackDownTimer = setInterval(function () {\n            e._trackClickHandler(t);\n          }, e.clickRepeatDelay), t.stopPropagation(), t.preventDefault()));\n        }\n\n        _trackClickHandler(t) {\n          const e = this;\n          if (e.disabled) return;\n          if (e._isThumbDragged) return clearInterval(e._trackDownTimer), void (e._trackDownTimer = null);\n          const a = e.$.thumb.getBoundingClientRect(),\n                r = t.pageX - window.pageXOffset,\n                n = t.pageY - window.pageYOffset,\n                i = (e.rightToLeft ? -1 : 1) * e.value;\n          \"horizontal\" === e.orientation ? r > (e._isThumbDragged ? e.dragStartX : a.right) ? e._updateValue(e.value + (e.rightToLeft ? -1 : 1) * e.largeStep) : r < (e._isThumbDragged ? e.dragStartX : a.left) && e._updateValue(e.value - (e.rightToLeft ? -1 : 1) * e.largeStep) : n > (e._isThumbDragged ? e.dragStartY : a.bottom) ? e._updateValue(e.value + e.largeStep) : n < (e._isThumbDragged ? e.dragStartY : a.top) && e._updateValue(e.value - e.largeStep), \"switchUntilReleased\" === e.mechanicalAction && e._updateValue(i);\n        }\n\n        _trackMoveHandler(t) {\n          \"touchmove\" === t.originalEvent.type && t.originalEvent.preventDefault();\n        }\n\n        _updateValue(t, e) {\n          const a = this;\n\n          if (!a._isUpdating && (1 === arguments.length && (e = t, t = a.value), (void 0 === e || isNaN(e)) && (e = a.min), e > a.max && (e = a.max), e < a.min && (e = a.min), a.value = e, t !== e)) {\n            if (a.setAttribute(\"aria-valuenow\", e), a._updateThumbPosition(), a.thumbCapture && \"switchWhenReleased\" === a.mechanicalAction) return;\n            if (a.onChange) return void a.onChange({\n              value: a.value,\n              oldValue: t,\n              min: a.min,\n              max: a.max,\n              context: a\n            });\n            a.$.fireEvent(\"change\", {\n              value: a.value,\n              oldValue: t,\n              min: a.min,\n              max: a.max\n            });\n          }\n        }\n\n        _updateThumbPosition() {\n          const t = this,\n                e = \"horizontal\" === t.orientation ? t.$.track.offsetWidth : t.$.track.offsetHeight,\n                a = t._calculateThumbSize(e),\n                r = e - a;\n\n          let n = (e - a) / (t.max - t.min) * (t.value - t.min);\n          t.rightToLeft && \"horizontal\" === t.orientation && (n = (e - a) / (t.max - t.min) * (t.max - t.value - t.min)), n = Math.min(r, Math.max(0, n)), \"vertical\" === t.orientation && t.$.thumb.style.top !== n + \"px\" ? t.$.thumb.style.top = n + \"px\" : \"horizontal\" === t.orientation && t.$.thumb.style.left !== n + \"px\" && (t.$.thumb.style.left = n + \"px\");\n        }\n\n      });\n      /***/\n    }\n    /******/\n\n  };\n  /************************************************************************/\n\n  /******/\n  // The module cache\n\n  /******/\n\n  var __webpack_module_cache__ = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n\n    if (cachedModule !== undefined) {\n      /******/\n      return cachedModule.exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/\n      // no module.id needed\n\n      /******/\n      // no module.loaded needed\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /* webpack/runtime/compat get default export */\n\n  /******/\n\n\n  (() => {\n    /******/\n    // getDefaultExport function for compatibility with non-harmony modules\n\n    /******/\n    __webpack_require__.n = module => {\n      /******/\n      var getter = module && module.__esModule ?\n      /******/\n      () => module['default'] :\n      /******/\n      () => module;\n      /******/\n\n      __webpack_require__.d(getter, {\n        a: getter\n      });\n      /******/\n\n\n      return getter;\n      /******/\n    };\n    /******/\n\n  })();\n  /******/\n\n  /******/\n\n  /* webpack/runtime/define property getters */\n\n  /******/\n\n\n  (() => {\n    /******/\n    // define getter functions for harmony exports\n\n    /******/\n    __webpack_require__.d = (exports, definition) => {\n      /******/\n      for (var key in definition) {\n        /******/\n        if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n          /******/\n          Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n          });\n          /******/\n        }\n        /******/\n\n      }\n      /******/\n\n    };\n    /******/\n\n  })();\n  /******/\n\n  /******/\n\n  /* webpack/runtime/hasOwnProperty shorthand */\n\n  /******/\n\n\n  (() => {\n    /******/\n    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n    /******/\n\n  })();\n  /******/\n\n  /************************************************************************/\n\n\n  var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be in strict mode.\n\n  (() => {\n    \"use strict\";\n    /* unused harmony export smartCarousel */\n\n    /* harmony import */\n\n    var _smart_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6321);\n    /* harmony import */\n\n\n    var _smart_element_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_smart_element_js__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */\n\n\n    var _smart_button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2612);\n    /* harmony import */\n\n\n    var _smart_button_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_smart_button_js__WEBPACK_IMPORTED_MODULE_1__);\n    /* harmony import */\n\n\n    var _smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9135);\n    /* harmony import */\n\n\n    var _smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2__);\n    /* harmony import */\n\n\n    var _smart_carousel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8585);\n    /* harmony import */\n\n\n    var _smart_carousel_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_smart_carousel_js__WEBPACK_IMPORTED_MODULE_3__);\n    /* Smart UI v10.2.12 (2021-10-25) \n    Copyright (c) 2011-2021 jQWidgets. \n    License: https://htmlelements.com/license/ */\n    //\n\n\n    class smartCarousel extends Smart.Component {\n      get name() {\n        return 'smartCarousel';\n      }\n\n    }\n  })();\n  /******/\n\n})();","map":null,"metadata":{},"sourceType":"script"}